<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[利用Object.keys遍历(forEach/map)对象数组，合并]]></title>
    <url>%2F2018%2F08%2F19%2FobjectKeys%2F</url>
    <content type="text"><![CDATA[js 中几种遍历对象的方法，包括 for..of、for..in、Object.keys、Object.getOwnProperty,它们在使用场景方面各有不同。 js 对象的属性中可直接用、可访问到的属性分为数据属性和访问器属性。 数据属性（实际存储属性值的属性）的四大特性：{ value: 属性值, writable: true/false, //控制是否可修改 enumerable: true/false, //控制是否可被for in遍历 configurable: true/false, //1. 控制是否可删除 2. 控制是否可修改前两个特性 3.一旦改为false不可逆 } 访问器属性（不实际存储数据，专门提供对其它数据/变量的保护）的四大特性：{ get:function(){return this.隐藏属性;}, set:function(val){ //如果val符合条件 this.隐藏属性=val //否则 报错 }, enumerable, configurable } 1. for..in 返回的是所有能够通过对象访问的、可枚举的属性，既包括存在于实例中的属性，也包括存在于原型中的实例,不能保证属性按对象原来的顺序输出。（可枚举-自身-原型） var obj = {a:1, b:2, c:3}; for (var prop in obj) { console.log(&quot;obj.&quot; + prop + &quot; = &quot; + obj[prop]); } // Output: // &quot;obj.a = 1&quot; // &quot;obj.b = 2&quot; // &quot;obj.c = 3&quot; 2. Object.keys 用于获取对象自身所有的可枚举的属性值，但不包括原型中的属性，然后返回一个由属性名组成的数组。注意它同 for..in 一样不能保证属性按对象原来的顺序输出。（可枚举-自身） // 数组 var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]; console.log(Object.keys(arr)); // console: [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;] // 类数组对象 var obj = { 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos; }; console.log(Object.keys(obj)); // console: [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;] // 类数组对象-随机下标 var anObj = { 100: &apos;a&apos;, 2: &apos;b&apos;, 7: &apos;c&apos; }; console.log(Object.keys(anObj)); // console: [&apos;2&apos;, &apos;7&apos;, &apos;100&apos;] // 不可枚举属性getFoo var myObj = Object.create({}, { getFoo: { value: function () { return this.foo; } } }); myObj.foo = 1; console.log(Object.keys(myObj)); // console: [&apos;foo&apos;] 3. Object.getOwnProperty 如果你想获取一个对象的所有属性，甚至包括不可枚举的，则可用该方法。其返回对象的所有自身属性的属性名组成的数组，但不会获取原型链上的属性。（可枚举&amp;不可枚举-自身） //获取不可枚举属性 var my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; }, enumerable: false } }); my_obj.foo = 1; console.log(Object.getOwnPropertyNames(my_obj).sort()); // [&quot;foo&quot;, &quot;getFoo&quot;] 下面的例子演示了该方法不会获取到原型链上的属性： function ParentClass() {} ParentClass.prototype.inheritedMethod = function() {}; function ChildClass() { this.prop = 5; this.method = function() {}; } ChildClass.prototype = new ParentClass; ChildClass.prototype.prototypeMethod = function() {}; console.log( Object.getOwnPropertyNames( new ChildClass() // [&quot;prop&quot;, &quot;method&quot;] ) ); 4. for..of es6 新增方法，主要来遍历可迭代的对象（包括 Array, Map, Set, arguments 等），它主要用来获取对象 value 值，而 for..in 主要获取对象 key 值。另外：可以由 break, continue, throw 或 return 终止。在这些情况下，迭代器关闭。 let iterable = [10, 20, 30]; for (let value of iterable) { value += 1; console.log(value); } // 11 // 21 // 31 与 for..in 循环之间的区别： Object.prototype.objCustom = function() {}; Array.prototype.arrCustom = function() {}; let iterable = [3, 5, 7]; iterable.foo = &apos;hello&apos;; for (let i in iterable) { console.log(i); // 0, 1, 2, &quot;foo&quot;, &quot;arrCustom&quot;, &quot;objCustom&quot; } for (let i in iterable) { if (iterable.hasOwnProperty(i)) { console.log(i); // 0, 1, 2, &quot;foo&quot; } } for (let i of iterable) { console.log(i); // 3, 5, 7 } 小结其实这几个方法之间的差异主要在属性是否可可枚举，是来自原型，还是实例。图片描述 开发中的实际应用需求：将如下两个从后台不同端口获取的 json 对象数组整合处理成如下注释部分的 json 对象 var goodsSpecJSON = [{ &quot;SpecA&quot;: &quot;颜色&quot; }, { &quot;SpecB&quot;: &quot;容量&quot; }, { &quot;SpecC&quot;: &quot;大小&quot; }, { &quot;SpecD&quot;: &quot;尺寸&quot; }, { &quot;SpecE&quot;: &quot;套餐&quot; }]; var goodsSpecList = [{ c_id: 3133, costPrice: 0, discountPrice: 0, earn: 0, etime: null, flag: 0, goodsDetailCount: 199, goodsDetailId: &quot;100PgQ2xy08121409mY27&quot;, goodsDetailInventory: 199, goodsDetailOff: 0, goodsDetailPic: &quot;/upload/messageImage/1523281057461_Personal.jpg,/upload/messageImage/1523282906972_Personal.jpg,/upload/messageImage/1523283570897_Personal.jpg&quot;, goodsDetailPrice: 188, goodsDetailSpec: &quot;&quot;, goodsId: &quot;00Y1kR4r1029X822731o0&quot;, isHost: 0, managerEarn: 0, postage: 10, profit: 0, specA: &quot;红色&quot;, specB: &quot;32G&quot;, specC: &quot;小&quot;, specD: &quot;4.7寸&quot;, specE: &quot;套餐一&quot;, unionEarn: 0, vipPrice: 0 }, { c_id: 3134, costPrice: 0, discountPrice: 0, earn: 0, etime: null, flag: 0, goodsDetailCount: 199, goodsDetailId: &quot;100PgQ2xy08121409mY27&quot;, goodsDetailInventory: 199, goodsDetailOff: 0, goodsDetailPic: &quot;/upload/messageImage/1523281057461_Personal.jpg,/upload/messageImage/1523282906972_Personal.jpg,/upload/messageImage/1523283570897_Personal.jpg&quot;, goodsDetailPrice: 188, goodsDetailSpec: &quot;&quot;, goodsId: &quot;00Y1kR4r1029X822731o0&quot;, isHost: 0, managerEarn: 0, postage: 10, profit: 0, specA: &quot;白色&quot;, specB: &quot;64G&quot;, specC: &quot;小&quot;, specD: &quot;5寸&quot;, specE: &quot;套餐二&quot;, unionEarn: 0, vipPrice: 0 }, { c_id: 3135, costPrice: 0, discountPrice: 0, earn: 0, etime: null, flag: 0, goodsDetailCount: 199, goodsDetailId: &quot;100PgQ2xy08121409mY27&quot;, goodsDetailInventory: 199, goodsDetailOff: 0, goodsDetailPic: &quot;/upload/messageImage/1523281057461_Personal.jpg,/upload/messageImage/1523282906972_Personal.jpg,/upload/messageImage/1523283570897_Personal.jpg&quot;, goodsDetailPrice: 188, goodsDetailSpec: &quot;&quot;, goodsId: &quot;00Y1kR4r1029X822731o0&quot;, isHost: 0, managerEarn: 0, postage: 10, profit: 0, specA: &quot;黑色&quot;, specB: &quot;128G&quot;, specC: &quot;小&quot;, specD: &quot;4.7寸&quot;, specE: &quot;套餐一&quot;, unionEarn: 0, vipPrice: 0 }, { c_id: 3136, costPrice: 0, discountPrice: 0, earn: 0, etime: null, flag: 0, goodsDetailCount: 199, goodsDetailId: &quot;100PgQ2xy08121409mY27&quot;, goodsDetailInventory: 199, goodsDetailOff: 0, goodsDetailPic: &quot;/upload/messageImage/1523281057461_Personal.jpg,/upload/messageImage/1523282906972_Personal.jpg,/upload/messageImage/1523283570897_Personal.jpg&quot;, goodsDetailPrice: 188, goodsDetailSpec: &quot;&quot;, goodsId: &quot;00Y1kR4r1029X822731o0&quot;, isHost: 0, managerEarn: 0, postage: 10, profit: 0, specA: &quot;蓝色&quot;, specB: &quot;64GG&quot;, specC: &quot;大&quot;, specD: &quot;4.5寸&quot;, specE: &quot;套餐二&quot;, unionEarn: 0, vipPrice: 0 }]; // var keys = { // &apos;颜色&apos;: [&apos;红色&apos;, &apos;白色&apos;], // &apos;容量&apos;: [&apos;8g&apos;, &apos;16g&apos;, &apos;32g&apos;, &apos;64g&apos;], // &apos;尺寸&apos;: [&apos;大&apos;, &apos;小&apos;, &apos;大&apos;], // &apos;套餐&apos;: [&apos;套餐一&apos;, &apos;套餐二&apos;, &apos;套餐三&apos;] // }; // //SKU，Stock Keeping Uint(库存量单位) // var sku_list = [{ // &apos;attrs&apos;: &apos;红色|16g|big|套餐二&apos;, // &apos;price&apos;: 120 // }, { // &apos;attrs&apos;: &apos;红色|8g|big|套餐一&apos;, // &apos;price&apos;: 10 // }, { // &apos;attrs&apos;: &apos;白色|16g|big|套餐二&apos;, // &apos;price&apos;: 28 // }, { // &apos;attrs&apos;: &apos;红色|64g|small|套餐三&apos;, // &apos;price&apos;: 220 // }, { // &apos;attrs&apos;: &apos;白色|32g|middle|套餐二&apos;, // &apos;price&apos;: 130 // }, { // &apos;attrs&apos;: &apos;红色|32g|big|套餐一&apos;, // &apos;price&apos;: 120 // }, ]; 实现：主要利用 Object.keys 方法获取对象的 key,value 值，配上 forEach 循环实现最终想要的结果。 var keys = {}; var sku_list = []; //原数据转换小写 goodsSpecJSON = goodsSpecJSON.map(function (keyo) { var key = Object.keys(keyo)[0]; var newkey = key.substring(0, 1).toLowerCase() + key.substring(1); var dic = {}; dic[newkey] = keyo[key]; return dic }); //生成keys goodsSpecJSON.forEach(function (keyo) { var key = Object.keys(keyo)[0]; //[&apos;specA&apos;] var val = keyo[key]; //颜色 if (!keys.hasOwnProperty(val)) { keys[val] = []; } var hash = {}; goodsSpecList.forEach(function (item, i) { if (hash[item[key]] === undefined) { hash[item[key]] = true; keys[val].push(item[key]); } // if (keys[val].indexOf(item[key]) === -1) { // keys[val].push(item[key]); // } }); }); console.log(keys) //生成sku_list goodsSpecList.forEach(function (item) { var dic = { attrs: &apos;&apos; }; goodsSpecJSON.forEach(function (keyo, j) { var key = Object.keys(keyo)[0]; dic.attrs += item[key] + (j === goodsSpecJSON.length - 1 ? &apos;&apos; : &apos;|&apos;); dic.price = item.goodsDetailPrice; dic.goodsDetailCount = item.goodsDetailCount; dic.goodsDetailId = item.goodsDetailId; }); sku_list.push(dic); }); console.log(sku_list) 输出结果：]]></content>
      <categories>
        <category>js</category>
        <category>Object.keys</category>
      </categories>
      <tags>
        <tag>Object.keys</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简洁的 Markdown 编辑器 Smark]]></title>
    <url>%2F2018%2F08%2F18%2FMarkdown%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[简洁的 Markdown 编辑器 Smark 说白了只是为了自己方便使用，并没什么新奇的东西。我使用 pandoc 来转化 markdown，但是我不想在修改文件时总是在编辑器、文字终端和浏览器间换来换去，因此我写了一个简单的编辑器，它在后台调用 pandoc 将当前编辑的 markdown 内容转化为 HTML，而后将 HTML 在 smark 中的浏览器中显示出来，就是这么回事。Smark 依赖于 pandoc、Qt 4.8 和 MathJax，在此向上述软件包开发者们致敬。请注意继承于 pandoc 的发布协议，Smark 同样遵循 GPL，如有任何疑问请联系 elerao.ao@gmail.com，我将尽快做出回复。 主要特性： Windows / Linux 等主流系统跨平台支持； 完美支持 LaTex 数学公式、脚注、尾注等，支持使用本地 MathJax 调用，不需要在线访问 MathJax CDN； 用户可配置的 Markdown 语法高亮显示，美观整洁； 多种格式文件导出支持，可将当前 Markdown 文件另存为 HTML、 Miscrosoft Word、OpenOffice / LibreOffice ODT Document、Latex、PDF、reStructured Text、Media Wiki markup、epub 以及 plain txt 等格式文件输出； 可通过用户指明 CSS 文件定义显示式样； 简洁友好的界面布局，尽可能地凸显正在编辑的内容； 系统、完备的各类快捷键，极大地提高了工作效率； 安装 Smark对于 Win32 平台的用户，您可以直接下载当前版本的可执行程序 Smark-X.X-Win32-portable.zip。对于其它平台的用户，可以下载当前版本的 Smark 源代码 Smark-X.X-src.zip在本平台上进行编译即可，一般地您可以按照如下步骤编译 Smark： 安装依赖的程序包: $ sudo apt-get install qtsdk $ sudo apt-get install pandoc 如果您不使用 apt-get 作为软件包管理器，自己谷歌搜索如何安装这两个程序包 下载 Smark 源代码 Smark-X.X-src.zip，解压并编译: $ qmake -project $ qmake $ make 把编译出的可执行文件移动到您的 [bin] 路径下即可使用，此时 Smark 将使用默认的 CSS 样式表和基于 MathJax CDN 的 MathJax 访问。如果想要得到与 Windows 平台下完全一致的体验，您还需下载 smark-2.0-resource.zip 解压倒 Smark 的安装目录下并进行设置。 运行截图Windows 7 下的 Smark 运行截图Windows 7 下的 Smark 配置选项对话框 FAQ64 位 Windows 下提示无法运行 pandoc：这是因为 Smark-X.X-Win32-portable.zip 中自带的 pandoc.exe 是 32 位系统下的，您可以通过下载安装包 pandoc-1.13.1-win64.msi 直接安装 64 位的 pandoc 而删除 Smark-X.X-Win32-portable.zip 中自带的 32 位的 pandoc.exe。 谷歌输入法无法输入问题貌似大凡使用 QTextEdit 部件的地方都存在这样的问题，这是因为您未开启 谷歌输入法的内嵌编辑模式，可通过点击 “谷歌输入法设置对话框” 中 “设置内嵌编辑模式” 按钮，后勾选 “使用内嵌编辑模式” 即可，如下图所示： TODO现有问题： 在 Qt5 下编译的 WebView 无法完整地加载 CSS 中的设置，Qt4 下没问题； 改动后的 Markdwon 语法高亮的超链接 和 加粗 的正则表达式匹配有问题； 导出 PDF 和打印时的内容分页问题； 待添加功能 仿照 QtCreator 3.1.xx 中编辑器的多行同时编辑实现，支持 Sublime 等软件所支持的多行同时编辑； 与 百度云、Google Drive、OneDrive 内容同步，这个以后再说； 附录：Smark 的快捷键列表 全局 Esc : 逐步隐藏所有不必要的部件，退出全屏显示 Tab : 增加所选诸行的缩进（四个空格） Ctrl + Tab : 减小所选诸行的缩进（四个空格） 文件菜单 Ctrl + N : 新建 markdown 文件 Ctrl + O : 打开 markdown 文件 Ctrl + S : 保存当前 markdown 文件 Ctrl + Shift + S : 将当前文件另存为支持的格式 Ctrl + W : 关闭当前 markdown 文件 Ctrl + P : 打印当前 markdown 文件 Ctrl + Q : 退出 Smark 视图菜单 F6 : 预览模式视图 F7 : 阅读模式视图 F8 : 编辑模式视图 F11 : 进入 / 退出全屏显示 编辑菜单 F5 : 刷新 HTML 显示 Ctrl + Shift + C : 查看 HTML 源代码 Ctrl + C : 复制 Ctrl + X : 剪切 Ctrl + P : 粘贴 Ctrl + Z : 撤消 Ctrl + Y : 重做 Ctrl + F : 查找 插入菜单 Ctrl + Shift + P : 插入图片 Ctrl + Shift + L : 插入链接 Ctrl + Shift + M : 插入数学公式 格式菜单 Ctrl + B : 加粗 Ctrl + I : 倾斜 Ctrl + U : 下划线 Ctrl + ] : 加大字号 Ctrl + [ : 减小字号 Ctrl + Down : 下标 Ctrl + Up : 上标 Ctrl + ` : 代码 Ctrl + &apos; : 引用 Ctrl + L : 内容左对齐 Ctrl + R : 内容右对齐 Ctrl + E : 内容居中]]></content>
      <categories>
        <category>工具类</category>
        <category>Smark</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
        <tag>Markdown</tag>
        <tag>Smark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>工具类</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
