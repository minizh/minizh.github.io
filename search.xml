<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MarkDown语法总结]]></title>
    <url>%2F2018%2F08%2F28%2FMarkDown%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1. 标题a. 一级标题123方式一： #1.一级标题方式二： 一级标题+分割线 ============= b. 二级标题加分割线12二级标题------- c. 1-6 标题：1234#1级标题##...### ### 6级标题 3. 分割线12*****----- 4. 首行缩进12中文： &amp;emsp;英文： &amp;nbsp; &emsp;&emsp;段落的前后要有空行，所谓的空行 是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。 5. 区块引用在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用，如： 12&gt; 区块引用&gt;&gt; 嵌套引用 效果： 区块引用 嵌套引用 6. 代码区块代码区块的建立是在每行加上 4 个空格或者一个制表符（如同写代码一样）。如普通段落： 首尾加制表符 1234void main()&#123; printf(&quot;Hello, Markdown.&quot;);&#125; 每行加四个空格 &lt; 首尾空需空行隔开 &gt;： void main() { printf(&quot;Hello, Markdown.&quot;); } &lt;div class=&quot;footer&quot;&gt; © 2004 Foo Corporation &lt;/div&gt; 7. 强调在强调内容两侧分别加上*或者_，如： *斜体*，_斜体_ **粗体**，__粗体__ 效果： _斜体_，_斜体_粗体，粗体 8. 列表使用·、+、或-标记无序列表，如： -（+*） 第一项 -（+*） 第二项 - （+*）第三项 `注意：标记后面最少有一个空格或制表符。若不在引用区块中，必须和前方段落之间存在空行。` 效果： 第一项 第二项 第三项 有序列表的标记方式是将上述的符号换成数字,并辅以.，如： 1. 第一项 2. 第二项 3. 第三项 效果： 第一项 第二项 第三项 9.链接链接可以由两种形式生成：行内式和参考式。行内式： [younghz的Markdown库](https://github.com/younghz/Markdown &quot;Markdown&quot;)。 效果： younghz 的 Markdown 库。 参考式： [younghz的Markdown库1][1] [younghz的Markdown库2][2] [1]:https://github.com/younghz/Markdown &quot;Markdown&quot; [2]:https://github.com/younghz/Markdown &quot;Markdown&quot; 效果： [younghz 的 Markdown 库 1][1][younghz 的 Markdown 库 2][2][1]:https://github.com/younghz/Markdown “Markdown”[2]:https://github.com/younghz/Markdown “Markdown” 注意： 上述的[1]:https:://github.com/younghz/Markdown “Markdown”不出现在区块中 10. 图片添加图片的形式和链接相似，只需在链接的基础上前方加一个！。 ![百度一下](https://www.baidu.com/img/bd_logo1.png &quot;百度一下&quot;) 11. 反斜杠\相当于反转义作用。使符号成为普通符号。 \`` \&amp;nbsp; 效果： ``\&nbsp; 12. 符号 `起到标记作用。如： `ctrl+a` 效果： ctrl+a]]></content>
      <categories>
        <category>工具类</category>
        <category>MarkDown语法</category>
      </categories>
      <tags>
        <tag>MarkDown基本语法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 遍历方法汇总]]></title>
    <url>%2F2018%2F08%2F20%2Fjs%E9%81%8D%E5%8E%86%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[1. for 循环使用临时变量，将长度缓存起来，避免重复获取数组长度，当数组长度较大时，优化效果才会比较明显。 123for(var i = 0, len = arr.length; i &lt; len; i++)&#123; //do something&#125; 2. es3 forEach 循环遍历数组中的每一项，没有返回值，对原数组没有影响。 注意: forEach() 1.对于空数组是不会执行回调函数的； 2.且无法在所有元素都传递给调用的函数之前终止遍历。 1234567//1 没有返回值arr.forEach((item,index,array) =&gt; &#123; //执行代码&#125;,this.value)//参数：item数组中的当前项, index当前项的索引, array原始数组；//this.value: 可选。传递给函数的值一般用 &quot;this&quot; 值。如果这个参数为空， &quot;undefined&quot; 会传递给 &quot;this&quot; 值//数组中有几项，那么传递进去的匿名回调函数就需要执行几次； 3. map 循环有返回值，可以 return 出来 与 forEach 不同点： forEach() 方法对数组的每个元素执行一次提供的函数。总是返回 undefined； map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。返回值是一个新的数组，并不影响原来的数组； 1234567891011121314arr.map(function(value,index,array)&#123; //do something return XXX&#125;)var ary = [12,23,24,42,1];var res = ary.map(function (item,index,ary ) &#123; return item*10;&#125;)console.log(res);//--&gt;[120,230,240,420,10]; 原数组拷贝了一份，并进行了修改console.log(ary);//--&gt;[12,23,24,42,1]； 原数组并未发生变化 4. for…of 遍历可以正确响应 break、continue 和 return 语句 123for (var value of myArray) &#123;console.log(value);&#125; 与 for…in 比较: 用 for in 不仅可以对数组,也可以对 enumerable 对象操作 1234var A = &#123;a:1,b:2,c:3,d:&quot;hello world&quot;&#125;;for(let k in A) &#123; console.log(k,A[k]);&#125; 总结来说:1.for in 总是得到对像的key或数组,字符串的下标，而 for of 和 forEach 一样，是直接得到值 2.for of 不能用于对象 5. filter 遍历不会改变原始数组,返回新数组 1234567891011121314var arr = [ &#123; id: 1, text: &apos;aa&apos;, done: true &#125;, &#123; id: 2, text: &apos;bb&apos;, done: false &#125;]console.log(arr.filter(item =&gt; item.done))//转为ES5arr.filter(function (item) &#123; return item.done;&#125;);var arr = [73,84,56, 22,100]var newArr = arr.filter(item =&gt; item&gt;80) //得到新数组 [84, 100]console.log(newArr,arr) 6. every 遍历every()是对数组中的每一项运行给定函数，如果该函数对每一项返回 true,则返回 true。 12345var arr = [ 1, 2, 3, 4, 5, 6 ];console.log( arr.every( function( item, index, array )&#123; return item &gt; 3; &#125;));false 7. some 遍历some()是对数组中每一项运行指定函数，如果该函数对任一项返回 true，则返回 true。 123456var arr = [ 1, 2, 3, 4, 5, 6 ]; console.log( arr.some( function( item, index, array )&#123; return item &gt; 3; &#125;));true 8. reducereduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。 1var total = [0,1,2,3,4].reduce((a, b)=&gt;a + b); //10 reduce 接受一个函数，函数有四个参数，分别是：上一次的值，当前值，当前值的索引，数组 123[0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, index, array)&#123; return previousValue + currentValue;&#125;); reduce 还有第二个参数，我们可以把这个参数作为第一次调用 callback 时的第一个参数，上面这个例子因为没有第二个参数，所以直接从数组的第二项开始，如果我们给了第二个参数为 5，那么结果就是这样的： 123[0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, index, array)&#123; return previousValue + currentValue;&#125;,5); 第一次调用的 previousValue 的值就用传入的第二个参数代替， 9. reduceRightreduceRight()方法的功能和 reduce()功能是一样的，不同的是 reduceRight()从数组的末尾向前将数组中的数组项做累加。 reduceRight()首次调用回调函数 callbackfn 时，prevValue 和 curValue 可以是两个值之一。如果调用 reduceRight() 时提供了 initialValue 参数，则 prevValue 等于 initialValue，curValue 等于数组中的最后一个值。如果没有提供 initialValue 参数，则 prevValue 等于数组最后一个值， curValue 等于数组中倒数第二个值。 12345var arr = [0,1,2,3,4];arr.reduceRight(function (preValue,curValue,index,array) &#123; return preValue + curValue;&#125;); // 10 回调将会被调用四次，每次调用的参数及返回值如下： 如果提供一个初始值 initialValue 为 5: 12345var arr = [0,1,2,3,4];arr.reduceRight(function (preValue,curValue,index,array) &#123; return preValue + curValue;&#125;, 5); // 15 回调将会被调用五次，每次调用的参数及返回的值如下： 同样的，可以对一个数组求和，也可以使用 reduceRight()方法: 12345678910111213var arr = [1,2,3,4,5,6];console.time(&quot;ruduceRight&quot;);Array.prototype.ruduceRightSum = function ()&#123; for (var i = 0; i &lt; 10000; i++) &#123; return this.reduceRight (function (preValue, curValue) &#123; return preValue + curValue; &#125;); &#125;&#125;arr.ruduceRightSum();console.log(&apos;最终的值：&apos; + arr.ruduceSum()); // 21console.timeEnd(&quot;ruduceRight&quot;); // 5.725ms 10. findfind()方法返回数组中符合测试函数条件的第一个元素。否则返回 undefined 12345678910111213141516171819202122232425var stu = [ &#123; name: &apos;张三&apos;, gender: &apos;男&apos;, age: 20 &#125;, &#123; name: &apos;王小毛&apos;, gender: &apos;男&apos;, age: 20 &#125;, &#123; name: &apos;李四&apos;, gender: &apos;男&apos;, age: 20 &#125;]function getStu(element)&#123; return element.name == &apos;李四&apos;&#125;stu.find(getStu)//返回结果为//&#123;name: &quot;李四&quot;, gender: &quot;男&quot;, age: 20&#125; ES6 方法 1stu.find((element) =&gt; (element.name == &apos;李四&apos;)) 11. findIndex对于数组中的每个元素，findIndex 方法都会调用一次回调函数（采用升序索引顺序），直到有元素返回 true。只要有一个元素返回 true，findIndex 立即返回该返回 true 的元素的索引值。如果数组中没有任何元素返回 true，则 findIndex 返回 -1。 findIndex 不会改变数组对象。 12345[1,2,3].findIndex(function(x) &#123; x == 2; &#125;);// Returns an index value of 1.[1,2,3].findIndex(x =&gt; x == 4);// Returns an index value of -1. 12. keys，values，entriesES6提供一个新的方法 —— keys()，ES8又新增了两个方法 entries()和 values() —— 用于遍历数组。它们都返回一个遍历器对象，可以用 for…of 循环进行遍历，唯一的区别是 keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历 123456789101112131415for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123; console.log(elem);&#125;// &apos;a&apos;// &apos;b&apos;for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123; console.log(index, elem);&#125;// 0 &quot;a&quot;// 1 &quot;b&quot;]]></content>
      <categories>
        <category>js</category>
        <category>js遍历</category>
      </categories>
      <tags>
        <tag>for of</tag>
        <tag>遍历数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Object.keys遍历(forEach/map)对象数组，合并]]></title>
    <url>%2F2018%2F08%2F20%2FobjectKeys%2F</url>
    <content type="text"><![CDATA[js 中几种遍历对象的方法，包括 for..of、for..in、Object.keys、Object.getOwnProperty,它们在使用场景方面各有不同。 js 对象的属性中可直接用、可访问到的属性分为数据属性和访问器属性。 数据属性（实际存储属性值的属性）的四大特性：{ value: 属性值, writable: true/false, //控制是否可修改 enumerable: true/false, //控制是否可被for in遍历 configurable: true/false, //1. 控制是否可删除 2. 控制是否可修改前两个特性 3.一旦改为false不可逆 } 访问器属性（不实际存储数据，专门提供对其它数据/变量的保护）的四大特性：{ get:function(){return this.隐藏属性;}, set:function(val){ //如果val符合条件 this.隐藏属性=val //否则 报错 }, enumerable, configurable } 1. for..in 返回的是所有能够通过对象访问的、可枚举的属性，既包括存在于实例中的属性，也包括存在于原型中的实例,不能保证属性按对象原来的顺序输出。（可枚举-自身-原型） var obj = {a:1, b:2, c:3}; for (var prop in obj) { console.log(&quot;obj.&quot; + prop + &quot; = &quot; + obj[prop]); } // Output: // &quot;obj.a = 1&quot; // &quot;obj.b = 2&quot; // &quot;obj.c = 3&quot; 2. Object.keys 用于获取对象自身所有的可枚举的属性值，但不包括原型中的属性，然后返回一个由属性名组成的数组。注意它同 for..in 一样不能保证属性按对象原来的顺序输出。（可枚举-自身） // 数组 var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]; console.log(Object.keys(arr)); // console: [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;] // 类数组对象 var obj = { 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos; }; console.log(Object.keys(obj)); // console: [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;] // 类数组对象-随机下标 var anObj = { 100: &apos;a&apos;, 2: &apos;b&apos;, 7: &apos;c&apos; }; console.log(Object.keys(anObj)); // console: [&apos;2&apos;, &apos;7&apos;, &apos;100&apos;] // 不可枚举属性getFoo var myObj = Object.create({}, { getFoo: { value: function () { return this.foo; } } }); myObj.foo = 1; console.log(Object.keys(myObj)); // console: [&apos;foo&apos;] 3. Object.getOwnProperty 如果你想获取一个对象的所有属性，甚至包括不可枚举的，则可用该方法。其返回对象的所有自身属性的属性名组成的数组，但不会获取原型链上的属性。（可枚举&amp;不可枚举-自身） //获取不可枚举属性 var my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; }, enumerable: false } }); my_obj.foo = 1; console.log(Object.getOwnPropertyNames(my_obj).sort()); // [&quot;foo&quot;, &quot;getFoo&quot;] 下面的例子演示了该方法不会获取到原型链上的属性： function ParentClass() {} ParentClass.prototype.inheritedMethod = function() {}; function ChildClass() { this.prop = 5; this.method = function() {}; } ChildClass.prototype = new ParentClass; ChildClass.prototype.prototypeMethod = function() {}; console.log( Object.getOwnPropertyNames( new ChildClass() // [&quot;prop&quot;, &quot;method&quot;] ) ); 4. for..of es6 新增方法，主要来遍历可迭代的对象（包括 Array, Map, Set, arguments 等），它主要用来获取对象 value 值，而 for..in 主要获取对象 key 值。另外：可以由 break, continue, throw 或 return 终止。在这些情况下，迭代器关闭。 let iterable = [10, 20, 30]; for (let value of iterable) { value += 1; console.log(value); } // 11 // 21 // 31 与 for..in 循环之间的区别： Object.prototype.objCustom = function() {}; Array.prototype.arrCustom = function() {}; let iterable = [3, 5, 7]; iterable.foo = &apos;hello&apos;; for (let i in iterable) { console.log(i); // 0, 1, 2, &quot;foo&quot;, &quot;arrCustom&quot;, &quot;objCustom&quot; } for (let i in iterable) { if (iterable.hasOwnProperty(i)) { console.log(i); // 0, 1, 2, &quot;foo&quot; } } for (let i of iterable) { console.log(i); // 3, 5, 7 } 小结其实这几个方法之间的差异主要在属性是否可可枚举，是来自原型，还是实例。图片描述 开发中的实际应用需求：将如下两个从后台不同端口获取的 json 对象数组整合处理成如下注释部分的 json 对象 var goodsSpecJSON = [{ &quot;SpecA&quot;: &quot;颜色&quot; }, { &quot;SpecB&quot;: &quot;容量&quot; }, { &quot;SpecC&quot;: &quot;大小&quot; }, { &quot;SpecD&quot;: &quot;尺寸&quot; }, { &quot;SpecE&quot;: &quot;套餐&quot; }]; var goodsSpecList = [{ c_id: 3133, costPrice: 0, discountPrice: 0, earn: 0, etime: null, flag: 0, goodsDetailCount: 199, goodsDetailId: &quot;100PgQ2xy08121409mY27&quot;, goodsDetailInventory: 199, goodsDetailOff: 0, goodsDetailPic: &quot;/upload/messageImage/1523281057461_Personal.jpg,/upload/messageImage/1523282906972_Personal.jpg,/upload/messageImage/1523283570897_Personal.jpg&quot;, goodsDetailPrice: 188, goodsDetailSpec: &quot;&quot;, goodsId: &quot;00Y1kR4r1029X822731o0&quot;, isHost: 0, managerEarn: 0, postage: 10, profit: 0, specA: &quot;红色&quot;, specB: &quot;32G&quot;, specC: &quot;小&quot;, specD: &quot;4.7寸&quot;, specE: &quot;套餐一&quot;, unionEarn: 0, vipPrice: 0 }, { c_id: 3134, costPrice: 0, discountPrice: 0, earn: 0, etime: null, flag: 0, goodsDetailCount: 199, goodsDetailId: &quot;100PgQ2xy08121409mY27&quot;, goodsDetailInventory: 199, goodsDetailOff: 0, goodsDetailPic: &quot;/upload/messageImage/1523281057461_Personal.jpg,/upload/messageImage/1523282906972_Personal.jpg,/upload/messageImage/1523283570897_Personal.jpg&quot;, goodsDetailPrice: 188, goodsDetailSpec: &quot;&quot;, goodsId: &quot;00Y1kR4r1029X822731o0&quot;, isHost: 0, managerEarn: 0, postage: 10, profit: 0, specA: &quot;白色&quot;, specB: &quot;64G&quot;, specC: &quot;小&quot;, specD: &quot;5寸&quot;, specE: &quot;套餐二&quot;, unionEarn: 0, vipPrice: 0 }, { c_id: 3135, costPrice: 0, discountPrice: 0, earn: 0, etime: null, flag: 0, goodsDetailCount: 199, goodsDetailId: &quot;100PgQ2xy08121409mY27&quot;, goodsDetailInventory: 199, goodsDetailOff: 0, goodsDetailPic: &quot;/upload/messageImage/1523281057461_Personal.jpg,/upload/messageImage/1523282906972_Personal.jpg,/upload/messageImage/1523283570897_Personal.jpg&quot;, goodsDetailPrice: 188, goodsDetailSpec: &quot;&quot;, goodsId: &quot;00Y1kR4r1029X822731o0&quot;, isHost: 0, managerEarn: 0, postage: 10, profit: 0, specA: &quot;黑色&quot;, specB: &quot;128G&quot;, specC: &quot;小&quot;, specD: &quot;4.7寸&quot;, specE: &quot;套餐一&quot;, unionEarn: 0, vipPrice: 0 }, { c_id: 3136, costPrice: 0, discountPrice: 0, earn: 0, etime: null, flag: 0, goodsDetailCount: 199, goodsDetailId: &quot;100PgQ2xy08121409mY27&quot;, goodsDetailInventory: 199, goodsDetailOff: 0, goodsDetailPic: &quot;/upload/messageImage/1523281057461_Personal.jpg,/upload/messageImage/1523282906972_Personal.jpg,/upload/messageImage/1523283570897_Personal.jpg&quot;, goodsDetailPrice: 188, goodsDetailSpec: &quot;&quot;, goodsId: &quot;00Y1kR4r1029X822731o0&quot;, isHost: 0, managerEarn: 0, postage: 10, profit: 0, specA: &quot;蓝色&quot;, specB: &quot;64GG&quot;, specC: &quot;大&quot;, specD: &quot;4.5寸&quot;, specE: &quot;套餐二&quot;, unionEarn: 0, vipPrice: 0 }]; // var keys = { // &apos;颜色&apos;: [&apos;红色&apos;, &apos;白色&apos;], // &apos;容量&apos;: [&apos;8g&apos;, &apos;16g&apos;, &apos;32g&apos;, &apos;64g&apos;], // &apos;尺寸&apos;: [&apos;大&apos;, &apos;小&apos;, &apos;大&apos;], // &apos;套餐&apos;: [&apos;套餐一&apos;, &apos;套餐二&apos;, &apos;套餐三&apos;] // }; // //SKU，Stock Keeping Uint(库存量单位) // var sku_list = [{ // &apos;attrs&apos;: &apos;红色|16g|big|套餐二&apos;, // &apos;price&apos;: 120 // }, { // &apos;attrs&apos;: &apos;红色|8g|big|套餐一&apos;, // &apos;price&apos;: 10 // }, { // &apos;attrs&apos;: &apos;白色|16g|big|套餐二&apos;, // &apos;price&apos;: 28 // }, { // &apos;attrs&apos;: &apos;红色|64g|small|套餐三&apos;, // &apos;price&apos;: 220 // }, { // &apos;attrs&apos;: &apos;白色|32g|middle|套餐二&apos;, // &apos;price&apos;: 130 // }, { // &apos;attrs&apos;: &apos;红色|32g|big|套餐一&apos;, // &apos;price&apos;: 120 // }, ]; 实现：主要利用 Object.keys 方法获取对象的 key,value 值，配上 forEach 循环实现最终想要的结果。 var keys = {}; var sku_list = []; //原数据转换小写 goodsSpecJSON = goodsSpecJSON.map(function (keyo) { var key = Object.keys(keyo)[0]; var newkey = key.substring(0, 1).toLowerCase() + key.substring(1); var dic = {}; dic[newkey] = keyo[key]; return dic }); //生成keys goodsSpecJSON.forEach(function (keyo) { var key = Object.keys(keyo)[0]; //[&apos;specA&apos;] var val = keyo[key]; //颜色 if (!keys.hasOwnProperty(val)) { keys[val] = []; } var hash = {}; goodsSpecList.forEach(function (item, i) { if (hash[item[key]] === undefined) { hash[item[key]] = true; keys[val].push(item[key]); } // if (keys[val].indexOf(item[key]) === -1) { // keys[val].push(item[key]); // } }); }); console.log(keys) //生成sku_list goodsSpecList.forEach(function (item) { var dic = { attrs: &apos;&apos; }; goodsSpecJSON.forEach(function (keyo, j) { var key = Object.keys(keyo)[0]; dic.attrs += item[key] + (j === goodsSpecJSON.length - 1 ? &apos;&apos; : &apos;|&apos;); dic.price = item.goodsDetailPrice; dic.goodsDetailCount = item.goodsDetailCount; dic.goodsDetailId = item.goodsDetailId; }); sku_list.push(dic); }); console.log(sku_list) 输出结果：]]></content>
      <categories>
        <category>js</category>
        <category>Object.keys</category>
      </categories>
      <tags>
        <tag>Object.keys</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简洁的 Markdown 编辑器 Smark]]></title>
    <url>%2F2018%2F08%2F19%2FMarkdown%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[简洁的 Markdown 编辑器 Smark 说白了只是为了自己方便使用，并没什么新奇的东西。我使用 pandoc 来转化 markdown，但是我不想在修改文件时总是在编辑器、文字终端和浏览器间换来换去，因此我写了一个简单的编辑器，它在后台调用 pandoc 将当前编辑的 markdown 内容转化为 HTML，而后将 HTML 在 smark 中的浏览器中显示出来，就是这么回事。Smark 依赖于 pandoc、Qt 4.8 和 MathJax，在此向上述软件包开发者们致敬。请注意继承于 pandoc 的发布协议，Smark 同样遵循 GPL，如有任何疑问请联系 elerao.ao@gmail.com，我将尽快做出回复。 主要特性： Windows / Linux 等主流系统跨平台支持； 完美支持 LaTex 数学公式、脚注、尾注等，支持使用本地 MathJax 调用，不需要在线访问 MathJax CDN； 用户可配置的 Markdown 语法高亮显示，美观整洁； 多种格式文件导出支持，可将当前 Markdown 文件另存为 HTML、 Miscrosoft Word、OpenOffice / LibreOffice ODT Document、Latex、PDF、reStructured Text、Media Wiki markup、epub 以及 plain txt 等格式文件输出； 可通过用户指明 CSS 文件定义显示式样； 简洁友好的界面布局，尽可能地凸显正在编辑的内容； 系统、完备的各类快捷键，极大地提高了工作效率； 安装 Smark对于 Win32 平台的用户，您可以直接下载当前版本的可执行程序 Smark-X.X-Win32-portable.zip。对于其它平台的用户，可以下载当前版本的 Smark 源代码 Smark-X.X-src.zip在本平台上进行编译即可，一般地您可以按照如下步骤编译 Smark： 安装依赖的程序包: $ sudo apt-get install qtsdk $ sudo apt-get install pandoc 如果您不使用 apt-get 作为软件包管理器，自己谷歌搜索如何安装这两个程序包 下载 Smark 源代码 Smark-X.X-src.zip，解压并编译: $ qmake -project $ qmake $ make 把编译出的可执行文件移动到您的 [bin] 路径下即可使用，此时 Smark 将使用默认的 CSS 样式表和基于 MathJax CDN 的 MathJax 访问。如果想要得到与 Windows 平台下完全一致的体验，您还需下载 smark-2.0-resource.zip 解压倒 Smark 的安装目录下并进行设置。 运行截图Windows 7 下的 Smark 运行截图Windows 7 下的 Smark 配置选项对话框 FAQ64 位 Windows 下提示无法运行 pandoc：这是因为 Smark-X.X-Win32-portable.zip 中自带的 pandoc.exe 是 32 位系统下的，您可以通过下载安装包 pandoc-1.13.1-win64.msi 直接安装 64 位的 pandoc 而删除 Smark-X.X-Win32-portable.zip 中自带的 32 位的 pandoc.exe。 谷歌输入法无法输入问题貌似大凡使用 QTextEdit 部件的地方都存在这样的问题，这是因为您未开启 谷歌输入法的内嵌编辑模式，可通过点击 “谷歌输入法设置对话框” 中 “设置内嵌编辑模式” 按钮，后勾选 “使用内嵌编辑模式” 即可，如下图所示： TODO现有问题： 在 Qt5 下编译的 WebView 无法完整地加载 CSS 中的设置，Qt4 下没问题； 改动后的 Markdwon 语法高亮的超链接 和 加粗 的正则表达式匹配有问题； 导出 PDF 和打印时的内容分页问题； 待添加功能 仿照 QtCreator 3.1.xx 中编辑器的多行同时编辑实现，支持 Sublime 等软件所支持的多行同时编辑； 与 百度云、Google Drive、OneDrive 内容同步，这个以后再说； 附录：Smark 的快捷键列表 全局 Esc : 逐步隐藏所有不必要的部件，退出全屏显示 Tab : 增加所选诸行的缩进（四个空格） Ctrl + Tab : 减小所选诸行的缩进（四个空格） 文件菜单 Ctrl + N : 新建 markdown 文件 Ctrl + O : 打开 markdown 文件 Ctrl + S : 保存当前 markdown 文件 Ctrl + Shift + S : 将当前文件另存为支持的格式 Ctrl + W : 关闭当前 markdown 文件 Ctrl + P : 打印当前 markdown 文件 Ctrl + Q : 退出 Smark 视图菜单 F6 : 预览模式视图 F7 : 阅读模式视图 F8 : 编辑模式视图 F11 : 进入 / 退出全屏显示 编辑菜单 F5 : 刷新 HTML 显示 Ctrl + Shift + C : 查看 HTML 源代码 Ctrl + C : 复制 Ctrl + X : 剪切 Ctrl + P : 粘贴 Ctrl + Z : 撤消 Ctrl + Y : 重做 Ctrl + F : 查找 插入菜单 Ctrl + Shift + P : 插入图片 Ctrl + Shift + L : 插入链接 Ctrl + Shift + M : 插入数学公式 格式菜单 Ctrl + B : 加粗 Ctrl + I : 倾斜 Ctrl + U : 下划线 Ctrl + ] : 加大字号 Ctrl + [ : 减小字号 Ctrl + Down : 下标 Ctrl + Up : 上标 Ctrl + ` : 代码 Ctrl + &apos; : 引用 Ctrl + L : 内容左对齐 Ctrl + R : 内容右对齐 Ctrl + E : 内容居中]]></content>
      <categories>
        <category>工具类</category>
        <category>Smark</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
        <tag>Markdown</tag>
        <tag>Smark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>工具类</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F08%2F19%2F404%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
