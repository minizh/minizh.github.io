<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES6小技巧]]></title>
    <url>%2F2018%2F10%2F09%2FES6%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[摘要：总结ES6新特性：默认参数、reduce、解构赋值和Set在使用时的一些小技巧。 ES6出来已经有好几年了，同时很多新特性可以被巧妙地运用在项目中。我想要列下其中一些，希望它们对你有用。 如果你还知道其他一些小技巧，欢迎留言。我很高兴把它们补充进来。 1. 强制要求参数ES6提供了默认参数值机制，允许你为参数设置默认值，防止函数在调用时没有传入这些参数。 在下面的例子中，我们写了一个required()函数作为参数a和b的默认值。这意味着如果a或b其中有一个参数没有在调用时传值，会默认required()函数，然后抛出错误。1234const required = () =&gt; &#123;throw new Error(&apos;Missing parameter&apos;)&#125;;const add = (a = required(), b = required()) =&gt; a + b;add(1, 2) //3add(1) // Error: Missing parameter. 2. 强大的reduce数组的reduce方法用途很广。它一般被用来把数组中每一项规约到单个值。但是你可以利用它做更多的事。 2.1 使用reduce同时实现map和filter假设现在有一个数列，你希望更新它的每一项（map的功能）然后筛选出一部分（filter的功能）。如果是先使用map然后filter的话，你需要遍历这个数组两次。 在下面的代码中，我们将数列中的值翻倍，然后挑选出那些大于50的数。有注意到我们是如何非常高效地使用reduce来同时完成map和filter方法的吗？ 1234567891011const numbers = [10, 20, 30, 40];const doubledOver50 = numbers.reduce((finalList, num) =&gt; &#123; num = num * 2; if (num &gt; 50) &#123; finalList.push(num); &#125; return finalList;&#125;, []);doubledOver50; // [60, 80] 关于reduce参数说明及一些高级操作数组reduce方法的高级技巧 。 2.2 使用reduce匹配圆括号reduce的另外一个用途是能够匹配给定字符串中的圆括号。对于一个含有圆括号的字符串，我们需要知道(和)的数量是否一致，并且(是否出现在)之前。 下面的代码中我们使用reduce可以轻松地解决这个问题。我们只需要先声明一个counter变量，初值为0。在遇到(时counter加一，遇到)时counter减一。如果左右括号数目匹配，那最终结果为0。12345678910111213141516171819//Returns 0 if balanced.const isParensBalanced = (str) =&gt; &#123; return str.split(&apos;&apos;).reduce((counter, char) =&gt; &#123; if(counter &lt; 0) &#123; //matched &quot;)&quot; before &quot;(&quot; return counter; &#125; else if(char === &apos;(&apos;) &#123; return ++counter; &#125; else if(char === &apos;)&apos;) &#123; return --counter; &#125; else &#123; //matched some other char return counter; &#125; &#125;, 0); //&lt;-- starting value of the counter&#125;isParensBalanced(&apos;(())&apos;) // 0 &lt;-- balancedisParensBalanced(&apos;(asdfds)&apos;) //0 &lt;-- balancedisParensBalanced(&apos;(()&apos;) // 1 &lt;-- not balancedisParensBalanced(&apos;)(&apos;) // -1 &lt;-- not balanced 2.3 统计数组中相同项的个数很多时候，你希望统计数组中重复出现项的个数然后用一个对象表示。那么你可以使用reduce方法处理这个数组。 下面的代码将统计每一种车的数目然后把总数用一个对象表示。1234567var cars = [&apos;BMW&apos;,&apos;Benz&apos;, &apos;Benz&apos;, &apos;Tesla&apos;, &apos;BMW&apos;, &apos;Toyota&apos;];var carsObj = cars.reduce(function (obj, name) &#123; obj[name] = obj[name] ? ++obj[name] : 1; return obj;&#125;, &#123;&#125;);carsObj; // =&gt; &#123; BMW: 2, Benz: 2, Tesla: 1, Toyota: 1 &#125;reduce的其他用处实在是太多了，我建议你阅读MDN的相关代码示例。 3. 对象解构3.1 删除不需要的属性有时候你不希望保留某些对象属性，也许是因为它们包含敏感信息或仅仅是太大了（just too big）。你可能会枚举整个对象然后删除它们，但实际上只需要简单的将这些无用属性赋值给变量，然后把想要保留的有用部分作为剩余参数就可以了。 下面的代码里，我们希望删除_internal和tooBig参数。我们可以把它们赋值给internal和tooBig变量，然后在cleanObject中存储剩下的属性以备后用。12let &#123;_internal, tooBig, ...cleanObject&#125; = &#123;el1: &apos;1&apos;, _internal:&quot;secret&quot;, tooBig:&#123;&#125;, el2: &apos;2&apos;, el3: &apos;3&apos;&#125;;console.log(cleanObject); // &#123;el1: &apos;1&apos;, el2: &apos;2&apos;, el3: &apos;3&apos;&#125; 3.2 在函数参数中解构嵌套对象在下面的代码中，engine是对象car中嵌套的一个对象。如果我们对engine的vin属性感兴趣，使用解构赋值可以很轻松地得到它。123456789101112var car = &#123; model: &apos;bmw 2018&apos;, engine: &#123; v6: true, turbo: true, vin: 12345 &#125;&#125;const modelAndVIN = (&#123;model, engine: &#123;vin&#125;&#125;) =&gt; &#123; console.log(`model: $&#123;model&#125; vin: $&#123;vin&#125;`);&#125;modelAndVIN(car); // =&gt; model: bmw 2018 vin: 12345 3.3 合并对象ES6带来了扩展运算符（…）。它一般被用来解构数组，但你也可以用它处理对象。 接下来，我们使用扩展运算符来展开一个新的对象，第二个对象中的属性值会改写第一个对象的属性值。比如object2的b和c就会改写object1的同名属性。1234let object1 = &#123; a:1, b:2,c:3 &#125;let object2 = &#123; b:30, c:40, d:50&#125;let merged = &#123;…object1, …object2&#125; //spread and re-add into mergedconsole.log(merged) // &#123;a:1, b:30, c:40, d:50&#125; 4. Sets4.1 使用Set实现数组去重在ES6中，因为Set只存储唯一值，所以你可以使用Set删除重复项。12let arr = [1, 1, 2, 2, 3, 3];let deduped = [...new Set(arr)] // [1, 2, 3] 4.2 对Set使用数组方法使用扩展运算符就可以简单的将Set转换为数组。所以你可以对Set使用Array的所有原生方法。 比如我们想要对下面的Set进行filter操作，获取大于3的项。12let mySet = new Set([1,2, 3, 4, 5]);var filtered = [...mySet].filter((x) =&gt; x &gt; 3) // [4, 5] 5. 数组解构有时候你会将函数返回的多个值放在一个数组里。我们可以使用数组解构来获取其中每一个值。 5.1 数值交换123456let param1 = 1;let param2 = 2;//swap and assign param1 &amp; param2 each others values[param1, param2] = [param2, param1];console.log(param1) // 2console.log(param2) // 1 5.2 接收函数返回的多个结果在下面的代码中，我们从/post中获取一个帖子，然后在/comments中获取相关评论。由于我们使用的是async/await，函数把返回值放在一个数组中。而我们使用数组解构后就可以把返回值直接赋给相应的变量。1234567async function getFullPost()&#123; return await Promise.all([ fetch(&apos;/post&apos;), fetch(&apos;/comments&apos;) ]);&#125;const [post, comments] = getFullPost();]]></content>
      <categories>
        <category>js</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>reduce</tag>
        <tag>解构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES7 异步神器 async-await]]></title>
    <url>%2F2018%2F10%2F05%2Fasync-await%2F</url>
    <content type="text"><![CDATA[关于异步处理，ES5的回调使我们陷入地狱，ES6的Promise使我们脱离魔障，终于、ES7的async-await带我们走向光明。今天就来学习一下 async-await。 1. async-await和Promise的关系经常会看到有了 async-await、promise 还有必要学习吗、async await优于promise的几个特点，接收了这些信息后，就蒙圈了。现在才知道，async-await是promise和generator的语法糖。只是为了让我们书写代码时更加流畅，当然也增强了代码的可读性。简单来说：async-await 是建立在 promise机制之上的，并不能取代其地位。 基本语法async function basicDemo() { let result = await Math.random(); console.log(result); } basicDemo(); // 0.6484863241051226 //Promise {[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: undefined} 上述代码就是async-await的基本使用形式。有两个陌生的关键字async、await，同时函数执行结果似乎返回了一个promise对象。 2. asyncasync用来表示函数是异步的，定义的函数会返回一个promise对象，可以使用then方法添加回调函数。 async function demo01() { return 123; } demo01().then(val =&gt; { console.log(val);// 123 }); 若 async 定义的函数有返回值，return 123;相当于Promise.resolve(123),没有声明式的 return则相当于执行了Promise.resolve(); 3. awaitawait 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。 function notAsyncFunc() { await Math.random(); } notAsyncFunc();//Uncaught SyntaxError: Unexpected identifier await 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决，如果等的是正常的表达式则立即执行。 function sleep(second) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(&apos; enough sleep~&apos;); }, second); }) } function normalFunc() { console.log(&apos;normalFunc&apos;); } async function awaitDemo() { await normalFunc(); console.log(&apos;something, ~~&apos;); let result = await sleep(2000); console.log(result);// 两秒之后会被打印出来 } awaitDemo(); // normalFunc // VM4036:13 something, ~~ // VM4036:15 enough sleep~ 希望通过上面的 demo，大家可以理解我上面的话。 4. 实例举例说明啊，你有三个请求需要发生，第三个请求是依赖于第二个请求的解构第二个请求依赖于第一个请求的结果。若用 ES5实现会有3层的回调，若用Promise 实现至少需要3个then。一个是代码横向发展，另一个是纵向发展。今天指给出 async-await 的实现哈~ //我们仍然使用 setTimeout 来模拟异步请求 function sleep(second, param) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(param); }, second); }) } async function test() { let result1 = await sleep(2000, &apos;req01&apos;); let result2 = await sleep(1000, &apos;req02&apos; + result1); let result3 = await sleep(500, &apos;req03&apos; + result2); console.log(` ${result3} ${result2} ${result1} `); } test(); //req03req02req01 //req02req01 //req01 5. 错误处理上述的代码好像给的都是resolve的情况，那么reject的时候我们该如何处理呢？ function sleep(second) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(&apos;want to sleep~&apos;); }, second); }) } async function errorDemo() { let result = await sleep(1000); console.log(result); } errorDemo();// VM706:11 Uncaught (in promise) want to sleep~ // 为了处理Promise.reject 的情况我们应该将代码块用 try catch 包裹一下 async function errorDemoSuper() { try { let result = await sleep(1000); console.log(result); } catch (err) { console.log(err); } } errorDemoSuper();// want to sleep~ // 有了 try catch 之后我们就能够拿到 Promise.reject 回来的数据了。 6. 小心你的并行处理!!!我这里为啥加了三个感叹号呢~，因为对于初学者来说一不小心就将 ajax 的并发请求发成了阻塞式同步的操作了，我就真真切切的在工作中写了这样的代码。await 若等待的是 promise 就会停止下来。业务是这样的，我有三个异步请求需要发送，相互没有关联，只是需要当请求都结束后将界面的 loading 清除掉即可。刚学完 async await 开心啊，到处乱用~ function sleep(second) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(&apos;request done! &apos; + Math.random()); }, second); }) } async function bugDemo() { await sleep(1000); await sleep(1000); await sleep(1000); console.log(&apos;clear the loading~&apos;); } bugDemo(); loading 确实是等待请求都结束完才清除的。但是你认真的观察下浏览器的 timeline 请求是一个结束后再发另一个的（若观察效果请发真实的 ajax 请求）那么，正常的处理是怎样的呢？ async function correctDemo() { let p1 = sleep(1000); let p2 = sleep(1000); let p3 = sleep(1000); await Promise.all([p1, p2, p3]); console.log(&apos;clear the loading~&apos;); } correctDemo();// clear the loading~ 恩， 完美。看吧~ async-await 并不能取代 promise. 7.await in for 循环最后一点了，await必须在async函数的上下文中的。 // 正常 for 循环 async function forDemo() { let arr = [1, 2, 3, 4, 5]; for (let i = 0; i &lt; arr.length; i ++) { await arr[i]; } } forDemo();//正常输出 // 因为想要炫技把 for循环写成下面这样 async function forBugDemo() { let arr = [1, 2, 3, 4, 5]; arr.forEach(item =&gt; { await item; }); } forBugDemo();// Uncaught SyntaxError: Unexpected identifier 8. refs不知道，我的意思有没有传递给大家。下面推荐几篇优秀的文章。 async 函数的含义和用法ES7 Async Await 聖經Understanding JavaScript’s async await]]></content>
      <categories>
        <category>js</category>
        <category>异步</category>
      </categories>
      <tags>
        <tag>异步-等待</tag>
        <tag>async-await</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 Promise 用法讲解]]></title>
    <url>%2F2018%2F10%2F04%2Fpromise%2F</url>
    <content type="text"><![CDATA[Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。 那就new一个 var p = new Promise(function(resolve, reject){ //做一些异步操作 setTimeout(function(){ console.log(&apos;执行完成&apos;); resolve(&apos;随便什么数据&apos;); }, 2000); }); Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected。不过在我们开始阶段可以先这么理解，后面再细究概念。 在上面的代码中，我们执行了一个异步操作，也就是setTimeout，2秒后，输出“执行完成”，并且调用resolve方法。 运行代码，会在2秒后输出“执行完成”。注意！我只是new了一个对象，并没有调用它，我们传进去的函数就已经执行了，这是需要注意的一个细节。所以我们用Promise的时候一般是包在一个函数中，在需要的时候去运行这个函数，如： function runAsync(){ var p = new Promise(function(resolve, reject){ //做一些异步操作 setTimeout(function(){ console.log(&apos;执行完成&apos;); resolve(&apos;随便什么数据&apos;); }, 2000); }); return p; } runAsync() 这时候你应该有两个疑问：1.包装这么一个函数有毛线用？2.resolve(‘随便什么数据’);这是干毛的？ 我们继续来讲。在我们包装好的函数最后，会return出Promise对象，也就是说，执行这个函数我们得到了一个Promise对象。还记得Promise对象上有then、catch方法吧？这就是强大之处了，看下面的代码： runAsync().then(function(data){ console.log(data); //后面可以用传过来的数据做些其他操作 //...... }); 在runAsync()的返回上直接调用then方法，then接收一个参数，是函数，并且会拿到我们在runAsync中调用resolve时传的的参数。运行这段代码，会在2秒后输出“执行完成”，紧接着输出“随便什么数据”。 这时候你应该有所领悟了，原来then里面的函数就跟我们平时的回调函数一个意思，能够在runAsync这个异步任务执行完成之后被执行。这就是Promise的作用了，简单来讲，就是能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。 你可能会不屑一顾，那么牛逼轰轰的Promise就这点能耐？我把回调函数封装一下，给runAsync传进去不也一样吗，就像这样： function runAsync(callback){ setTimeout(function(){ console.log(&apos;执行完成&apos;); callback(&apos;随便什么数据&apos;); }, 2000); } runAsync(function(data){ console.log(data); }); 效果也是一样的，还费劲用Promise干嘛。那么问题来了，有多层回调该怎么办？如果callback也是一个异步操作，而且执行完后也需要有相应的回调函数，该怎么办呢？总不能再定义一个callback2，然后给callback传进去吧。而Promise的优势在于，可以在then方法中继续写Promise对象并返回，然后继续调用then来进行回调操作。 1. 链式操作的用法所以，从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。所以使用Promise的正确场景是这样的： runAsync1() .then(function(data){ console.log(data); return runAsync2(); }) .then(function(data){ console.log(data); return runAsync3(); }) .then(function(data){ console.log(data); }); 这样能够按顺序，每隔两秒输出每个异步回调中的内容，在runAsync2中传给resolve的数据，能在接下来的then方法中拿到。运行结果如下： 猜猜runAsync1、runAsync2、runAsync3这三个函数都是如何定义的？没错，就是下面这样 function runAsync1(){ var p = new Promise(function(resolve, reject){ //做一些异步操作 setTimeout(function(){ console.log(&apos;异步任务1执行完成&apos;); resolve(&apos;随便什么数据1&apos;); }, 1000); }); return p; } function runAsync2(){ var p = new Promise(function(resolve, reject){ //做一些异步操作 setTimeout(function(){ console.log(&apos;异步任务2执行完成&apos;); resolve(&apos;随便什么数据2&apos;); }, 2000); }); return p; } function runAsync3(){ var p = new Promise(function(resolve, reject){ //做一些异步操作 setTimeout(function(){ console.log(&apos;异步任务3执行完成&apos;); resolve(&apos;随便什么数据3&apos;); }, 2000); }); return p; } 在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了，比如我们把上面的代码修改成这样： runAsync1() .then(function(data){ console.log(data); return runAsync2(); }) .then(function(data){ console.log(data); return &apos;直接返回数据&apos;; //这里直接返回数据 }) .then(function(data){ console.log(data); }); 那么输出就变成了这样： 2. reject的用法到这里，你应该对“Promise是什么玩意”有了最基本的了解。那么我们接着来看看ES6的Promise还有哪些功能。我们光用了resolve，还没用reject呢，它是做什么的呢？事实上，我们前面的例子都是只有“执行成功”的回调，还没有“失败”的情况，reject的作用就是把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。看下面的代码。 function getNumber(){ var p = new Promise(function(resolve, reject){ //做一些异步操作 setTimeout(function(){ var num = Math.ceil(Math.random()*10); //生成1-10的随机数 if(num&lt;=5){ resolve(num); } else{ reject(&apos;数字太大了&apos;); } }, 2000); }); return p; } getNumber() .then( function(data){ console.log(&apos;resolved&apos;); console.log(data); }, function(reason, data){ console.log(&apos;rejected&apos;); console.log(reason); } ); getNumber函数用来异步获取一个数字，2秒后执行完成，如果数字小于等于5，我们认为是“成功”了，调用resolve修改Promise的状态。否则我们认为是“失败”了，调用reject并传递一个参数，作为失败的原因。 运行getNumber并且在then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果： 或者s 3. catch的用法我们知道Promise对象除了then方法，还有一个catch方法，它是做什么用的呢？其实它和then的第二个参数一样，用来指定reject的回调，用法是这样： getNumber() .then(function(data){ console.log(&apos;resolved&apos;); console.log(data); }) .catch(function(reason){ console.log(&apos;rejected&apos;); console.log(reason); }); 效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。请看下面的代码： getNumber() .then(function(data){ console.log(&apos;resolved&apos;); console.log(data); console.log(somedata); //此处的somedata未定义 }) .catch(function(reason){ console.log(&apos;rejected&apos;); console.log(reason); }); 在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果： 也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错了，这与我们的try/catch语句有相同的功能。 4. all的用法Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。我们仍旧使用上面定义好的runAsync1、runAsync2、runAsync3这三个函数，看下面的例子： Promise .all([runAsync1(), runAsync2(), runAsync3()]) .then(function(results){ console.log(results); }); 用Promise.all来执行，all接收一个数组参数，里面的值最终都算返回Promise对象。这样，三个异步操作的并行执行的，等到它们都执行完后才会进到then里面。那么，三个异步操作返回的数据哪里去了呢？都在then里面呢，all会把所有异步操作的结果放进一个数组中传给then，就是上面的results。所以上面代码的输出结果就是： 有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。 5. race的用法all方法的效果实际上是「谁跑的慢，以谁为准执行回调」，那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」，这就是race方法，这个词本来就是赛跑的意思。race的用法与all一样，我们把上面runAsync1的延时改为1秒来看一下： Promise .race([runAsync1(), runAsync2(), runAsync3()]) .then(function(results){ console.log(results); }); 这三个异步操作同样是并行执行的。结果你应该可以猜到，1秒后runAsync1已经执行完了，此时then里面的就执行了。结果是这样的： 你猜对了吗？不完全，是吧。在then里面的回调开始执行时，runAsync2()和runAsync3()并没有停止，仍旧再执行。于是再过1秒后，输出了他们结束的标志。 这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下： //请求某个图片资源 function requestImg(){ var p = new Promise(function(resolve, reject){ var img = new Image(); img.onload = function(){ resolve(img); } img.src = &apos;xxxxxx&apos;; }); return p; } //延时函数，用于给请求计时 function timeout(){ var p = new Promise(function(resolve, reject){ setTimeout(function(){ reject(&apos;图片请求超时&apos;); }, 5000); }); return p; } Promise .race([requestImg(), timeout()]) .then(function(results){ console.log(results); }) .catch(function(reason){ console.log(reason); }); requestImg函数会异步请求一张图片，我把地址写为”xxxxxx”，所以肯定是无法成功请求到的。timeout函数是一个延时5秒的异步操作。我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入then方法，执行正常的流程。如果5秒钟图片还未成功返回，那么timeout就跑赢了，则进入catch，报出“图片请求超时”的信息。运行结果如下：]]></content>
      <categories>
        <category>js</category>
        <category>异步</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 遍历方法汇总]]></title>
    <url>%2F2018%2F08%2F29%2Fjs%E9%81%8D%E5%8E%86%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[1. for 循环使用临时变量，将长度缓存起来，避免重复获取数组长度，当数组长度较大时，优化效果才会比较明显。 123for(var i = 0, len = arr.length; i &lt; len; i++)&#123; //do something&#125; 2. es3 forEach 循环遍历数组中的每一项，没有返回值，对原数组没有影响。 注意: forEach() 1.对于空数组是不会执行回调函数的； 2.且无法在所有元素都传递给调用的函数之前终止遍历。 1234567//1 没有返回值arr.forEach((item,index,array) =&gt; &#123; //执行代码&#125;,this.value)//参数：item数组中的当前项, index当前项的索引, array原始数组；//this.value: 可选。传递给函数的值一般用 &quot;this&quot; 值。如果这个参数为空， &quot;undefined&quot; 会传递给 &quot;this&quot; 值//数组中有几项，那么传递进去的匿名回调函数就需要执行几次； 3. map 循环有返回值，可以 return 出来 与 forEach 不同点： forEach() 方法对数组的每个元素执行一次提供的函数。总是返回 undefined； map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。返回值是一个新的数组，并不影响原来的数组； 1234567891011121314arr.map(function(value,index,array)&#123; //do something return XXX&#125;)var ary = [12,23,24,42,1];var res = ary.map(function (item,index,ary ) &#123; return item*10;&#125;)console.log(res);//--&gt;[120,230,240,420,10]; 原数组拷贝了一份，并进行了修改console.log(ary);//--&gt;[12,23,24,42,1]； 原数组并未发生变化 4. for…of 遍历可以正确响应 break、continue 和 return 语句 123for (var value of myArray) &#123;console.log(value);&#125; 与 for…in 比较: 用 for in 不仅可以对数组,也可以对 enumerable 对象操作 1234var A = &#123;a:1,b:2,c:3,d:&quot;hello world&quot;&#125;;for(let k in A) &#123; console.log(k,A[k]);&#125; 总结来说:1.for in 总是得到对像的key或数组,字符串的下标，而 for of 和 forEach 一样，是直接得到值 2.for of 不能用于对象 5. filter 遍历不会改变原始数组,返回新数组 1234567891011121314var arr = [ &#123; id: 1, text: &apos;aa&apos;, done: true &#125;, &#123; id: 2, text: &apos;bb&apos;, done: false &#125;]console.log(arr.filter(item =&gt; item.done))//转为ES5arr.filter(function (item) &#123; return item.done;&#125;);var arr = [73,84,56, 22,100]var newArr = arr.filter(item =&gt; item&gt;80) //得到新数组 [84, 100]console.log(newArr,arr) 6. every 遍历every()是对数组中的每一项运行给定函数，如果该函数对每一项返回 true,则返回 true。 12345var arr = [ 1, 2, 3, 4, 5, 6 ];console.log( arr.every( function( item, index, array )&#123; return item &gt; 3; &#125;));false 7. some 遍历some()是对数组中每一项运行指定函数，如果该函数对任一项返回 true，则返回 true。 123456var arr = [ 1, 2, 3, 4, 5, 6 ]; console.log( arr.some( function( item, index, array )&#123; return item &gt; 3; &#125;));true 8. reducereduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。 1var total = [0,1,2,3,4].reduce((a, b)=&gt;a + b); //10 reduce 接受一个函数，函数有四个参数，分别是：上一次的值，当前值，当前值的索引，数组 123[0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, index, array)&#123; return previousValue + currentValue;&#125;); reduce 还有第二个参数，我们可以把这个参数作为第一次调用 callback 时的第一个参数，上面这个例子因为没有第二个参数，所以直接从数组的第二项开始，如果我们给了第二个参数为 5，那么结果就是这样的： 123[0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, index, array)&#123; return previousValue + currentValue;&#125;,5); 第一次调用的 previousValue 的值就用传入的第二个参数代替， 9. reduceRightreduceRight()方法的功能和 reduce()功能是一样的，不同的是 reduceRight()从数组的末尾向前将数组中的数组项做累加。 reduceRight()首次调用回调函数 callbackfn 时，prevValue 和 curValue 可以是两个值之一。如果调用 reduceRight() 时提供了 initialValue 参数，则 prevValue 等于 initialValue，curValue 等于数组中的最后一个值。如果没有提供 initialValue 参数，则 prevValue 等于数组最后一个值， curValue 等于数组中倒数第二个值。 12345var arr = [0,1,2,3,4];arr.reduceRight(function (preValue,curValue,index,array) &#123; return preValue + curValue;&#125;); // 10 回调将会被调用四次，每次调用的参数及返回值如下： 如果提供一个初始值 initialValue 为 5: 12345var arr = [0,1,2,3,4];arr.reduceRight(function (preValue,curValue,index,array) &#123; return preValue + curValue;&#125;, 5); // 15 回调将会被调用五次，每次调用的参数及返回的值如下： 同样的，可以对一个数组求和，也可以使用 reduceRight()方法: 12345678910111213var arr = [1,2,3,4,5,6];console.time(&quot;ruduceRight&quot;);Array.prototype.ruduceRightSum = function ()&#123; for (var i = 0; i &lt; 10000; i++) &#123; return this.reduceRight (function (preValue, curValue) &#123; return preValue + curValue; &#125;); &#125;&#125;arr.ruduceRightSum();console.log(&apos;最终的值：&apos; + arr.ruduceSum()); // 21console.timeEnd(&quot;ruduceRight&quot;); // 5.725ms 10. findfind()方法返回数组中符合测试函数条件的第一个元素。否则返回 undefined 12345678910111213141516171819202122232425var stu = [ &#123; name: &apos;张三&apos;, gender: &apos;男&apos;, age: 20 &#125;, &#123; name: &apos;王小毛&apos;, gender: &apos;男&apos;, age: 20 &#125;, &#123; name: &apos;李四&apos;, gender: &apos;男&apos;, age: 20 &#125;]function getStu(element)&#123; return element.name == &apos;李四&apos;&#125;stu.find(getStu)//返回结果为//&#123;name: &quot;李四&quot;, gender: &quot;男&quot;, age: 20&#125; ES6 方法 1stu.find((element) =&gt; (element.name == &apos;李四&apos;)) 11. findIndex对于数组中的每个元素，findIndex 方法都会调用一次回调函数（采用升序索引顺序），直到有元素返回 true。只要有一个元素返回 true，findIndex 立即返回该返回 true 的元素的索引值。如果数组中没有任何元素返回 true，则 findIndex 返回 -1。 findIndex 不会改变数组对象。 12345[1,2,3].findIndex(function(x) &#123; x == 2; &#125;);// Returns an index value of 1.[1,2,3].findIndex(x =&gt; x == 4);// Returns an index value of -1. 12. keys，values，entriesES6提供一个新的方法 —— keys()，ES8又新增了两个方法 entries()和 values() —— 用于遍历数组。它们都返回一个遍历器对象，可以用 for…of 循环进行遍历，唯一的区别是 keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历 123456789101112131415for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123; console.log(elem);&#125;// &apos;a&apos;// &apos;b&apos;for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123; console.log(index, elem);&#125;// 0 &quot;a&quot;// 1 &quot;b&quot;]]></content>
      <categories>
        <category>js</category>
        <category>js遍历</category>
      </categories>
      <tags>
        <tag>for of</tag>
        <tag>遍历数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法总结]]></title>
    <url>%2F2018%2F08%2F28%2FMarkDown%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1. 标题a. 一级标题123方式一： #1.一级标题方式二： 一级标题+分割线 ============= b. 二级标题加分割线12二级标题------- c. 1-6 标题：1234#1级标题##...### ### 6级标题 3. 分割线12*****----- 4. 首行缩进12中文： &amp;emsp;英文： &amp;nbsp; &emsp;&emsp;段落的前后要有空行，所谓的空行 是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。 5. 区块引用在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用，如： 12&gt; 区块引用&gt;&gt; 嵌套引用 效果： 区块引用 嵌套引用 6. 代码区块代码区块的建立是在每行加上 4 个空格或者一个制表符（如同写代码一样）。如普通段落： 首尾加制表符 1234void main()&#123; printf(&quot;Hello, Markdown.&quot;);&#125; 每行加四个空格 &lt; 首尾空需空行隔开 &gt;： void main() { printf(&quot;Hello, Markdown.&quot;); } &lt;div class=&quot;footer&quot;&gt; © 2004 Foo Corporation &lt;/div&gt; 7. 强调在强调内容两侧分别加上*或者_，如： *斜体*，_斜体_ **粗体**，__粗体__ 效果： _斜体_，_斜体_粗体，粗体 8. 列表使用·、+、或-标记无序列表，如： -（+*） 第一项 -（+*） 第二项 - （+*）第三项 `注意：标记后面最少有一个空格或制表符。若不在引用区块中，必须和前方段落之间存在空行。` 效果： 第一项 第二项 第三项 有序列表的标记方式是将上述的符号换成数字,并辅以.，如： 1. 第一项 2. 第二项 3. 第三项 效果： 第一项 第二项 第三项 9.链接链接可以由两种形式生成：行内式和参考式。行内式： [younghz的Markdown库](https://github.com/younghz/Markdown &quot;Markdown&quot;)。 效果： younghz 的 Markdown 库。 参考式： [younghz的Markdown库1][1] [younghz的Markdown库2][2] [1]:https://github.com/younghz/Markdown &quot;Markdown&quot; [2]:https://github.com/younghz/Markdown &quot;Markdown&quot; 效果： [younghz 的 Markdown 库 1][1][younghz 的 Markdown 库 2][2][1]:https://github.com/younghz/Markdown “Markdown”[2]:https://github.com/younghz/Markdown “Markdown” 注意： 上述的[1]:https:://github.com/younghz/Markdown “Markdown”不出现在区块中 10. 图片添加图片的形式和链接相似，只需在链接的基础上前方加一个！。 ![百度一下](https://www.baidu.com/img/bd_logo1.png &quot;百度一下&quot;) 11. 反斜杠\相当于反转义作用。使符号成为普通符号。 \`` \&amp;nbsp; 效果： ``\&nbsp; 12. 符号 `起到标记作用。如： `ctrl+a` 效果： ctrl+a]]></content>
      <categories>
        <category>工具类</category>
        <category>MarkDown语法</category>
      </categories>
      <tags>
        <tag>MarkDown基本语法总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Object.keys遍历(forEach/map)对象数组，合并]]></title>
    <url>%2F2018%2F08%2F20%2FobjectKeys%2F</url>
    <content type="text"><![CDATA[js 中几种遍历对象的方法，包括 for..of、for..in、Object.keys、Object.getOwnProperty,它们在使用场景方面各有不同。 js 对象的属性中可直接用、可访问到的属性分为数据属性和访问器属性。 数据属性（实际存储属性值的属性）的四大特性：{ value: 属性值, writable: true/false, //控制是否可修改 enumerable: true/false, //控制是否可被for in遍历 configurable: true/false, //1. 控制是否可删除 2. 控制是否可修改前两个特性 3.一旦改为false不可逆 } 访问器属性（不实际存储数据，专门提供对其它数据/变量的保护）的四大特性：{ get:function(){return this.隐藏属性;}, set:function(val){ //如果val符合条件 this.隐藏属性=val //否则 报错 }, enumerable, configurable } 1. for..in 返回的是所有能够通过对象访问的、可枚举的属性，既包括存在于实例中的属性，也包括存在于原型中的实例,不能保证属性按对象原来的顺序输出。（可枚举-自身-原型） var obj = {a:1, b:2, c:3}; for (var prop in obj) { console.log(&quot;obj.&quot; + prop + &quot; = &quot; + obj[prop]); } // Output: // &quot;obj.a = 1&quot; // &quot;obj.b = 2&quot; // &quot;obj.c = 3&quot; 2. Object.keys 用于获取对象自身所有的可枚举的属性值，但不包括原型中的属性，然后返回一个由属性名组成的数组。注意它同 for..in 一样不能保证属性按对象原来的顺序输出。（可枚举-自身） // 数组 var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]; console.log(Object.keys(arr)); // console: [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;] // 类数组对象 var obj = { 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos; }; console.log(Object.keys(obj)); // console: [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;] // 类数组对象-随机下标 var anObj = { 100: &apos;a&apos;, 2: &apos;b&apos;, 7: &apos;c&apos; }; console.log(Object.keys(anObj)); // console: [&apos;2&apos;, &apos;7&apos;, &apos;100&apos;] // 不可枚举属性getFoo var myObj = Object.create({}, { getFoo: { value: function () { return this.foo; } } }); myObj.foo = 1; console.log(Object.keys(myObj)); // console: [&apos;foo&apos;] 3. Object.getOwnProperty 如果你想获取一个对象的所有属性，甚至包括不可枚举的，则可用该方法。其返回对象的所有自身属性的属性名组成的数组，但不会获取原型链上的属性。（可枚举&amp;不可枚举-自身） //获取不可枚举属性 var my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; }, enumerable: false } }); my_obj.foo = 1; console.log(Object.getOwnPropertyNames(my_obj).sort()); // [&quot;foo&quot;, &quot;getFoo&quot;] 下面的例子演示了该方法不会获取到原型链上的属性： function ParentClass() {} ParentClass.prototype.inheritedMethod = function() {}; function ChildClass() { this.prop = 5; this.method = function() {}; } ChildClass.prototype = new ParentClass; ChildClass.prototype.prototypeMethod = function() {}; console.log( Object.getOwnPropertyNames( new ChildClass() // [&quot;prop&quot;, &quot;method&quot;] ) ); 4. for..of es6 新增方法，主要来遍历可迭代的对象（包括 Array, Map, Set, arguments 等），它主要用来获取对象 value 值，而 for..in 主要获取对象 key 值。另外：可以由 break, continue, throw 或 return 终止。在这些情况下，迭代器关闭。 let iterable = [10, 20, 30]; for (let value of iterable) { value += 1; console.log(value); } // 11 // 21 // 31 与 for..in 循环之间的区别： Object.prototype.objCustom = function() {}; Array.prototype.arrCustom = function() {}; let iterable = [3, 5, 7]; iterable.foo = &apos;hello&apos;; for (let i in iterable) { console.log(i); // 0, 1, 2, &quot;foo&quot;, &quot;arrCustom&quot;, &quot;objCustom&quot; } for (let i in iterable) { if (iterable.hasOwnProperty(i)) { console.log(i); // 0, 1, 2, &quot;foo&quot; } } for (let i of iterable) { console.log(i); // 3, 5, 7 } 小结其实这几个方法之间的差异主要在属性是否可可枚举，是来自原型，还是实例。图片描述 开发中的实际应用需求：将如下两个从后台不同端口获取的 json 对象数组整合处理成如下注释部分的 json 对象 var goodsSpecJSON = [{ &quot;SpecA&quot;: &quot;颜色&quot; }, { &quot;SpecB&quot;: &quot;容量&quot; }, { &quot;SpecC&quot;: &quot;大小&quot; }, { &quot;SpecD&quot;: &quot;尺寸&quot; }, { &quot;SpecE&quot;: &quot;套餐&quot; }]; var goodsSpecList = [{ c_id: 3133, costPrice: 0, discountPrice: 0, earn: 0, etime: null, flag: 0, goodsDetailCount: 199, goodsDetailId: &quot;100PgQ2xy08121409mY27&quot;, goodsDetailInventory: 199, goodsDetailOff: 0, goodsDetailPic: &quot;/upload/messageImage/1523281057461_Personal.jpg,/upload/messageImage/1523282906972_Personal.jpg,/upload/messageImage/1523283570897_Personal.jpg&quot;, goodsDetailPrice: 188, goodsDetailSpec: &quot;&quot;, goodsId: &quot;00Y1kR4r1029X822731o0&quot;, isHost: 0, managerEarn: 0, postage: 10, profit: 0, specA: &quot;红色&quot;, specB: &quot;32G&quot;, specC: &quot;小&quot;, specD: &quot;4.7寸&quot;, specE: &quot;套餐一&quot;, unionEarn: 0, vipPrice: 0 }, { c_id: 3134, costPrice: 0, discountPrice: 0, earn: 0, etime: null, flag: 0, goodsDetailCount: 199, goodsDetailId: &quot;100PgQ2xy08121409mY27&quot;, goodsDetailInventory: 199, goodsDetailOff: 0, goodsDetailPic: &quot;/upload/messageImage/1523281057461_Personal.jpg,/upload/messageImage/1523282906972_Personal.jpg,/upload/messageImage/1523283570897_Personal.jpg&quot;, goodsDetailPrice: 188, goodsDetailSpec: &quot;&quot;, goodsId: &quot;00Y1kR4r1029X822731o0&quot;, isHost: 0, managerEarn: 0, postage: 10, profit: 0, specA: &quot;白色&quot;, specB: &quot;64G&quot;, specC: &quot;小&quot;, specD: &quot;5寸&quot;, specE: &quot;套餐二&quot;, unionEarn: 0, vipPrice: 0 }, { c_id: 3135, costPrice: 0, discountPrice: 0, earn: 0, etime: null, flag: 0, goodsDetailCount: 199, goodsDetailId: &quot;100PgQ2xy08121409mY27&quot;, goodsDetailInventory: 199, goodsDetailOff: 0, goodsDetailPic: &quot;/upload/messageImage/1523281057461_Personal.jpg,/upload/messageImage/1523282906972_Personal.jpg,/upload/messageImage/1523283570897_Personal.jpg&quot;, goodsDetailPrice: 188, goodsDetailSpec: &quot;&quot;, goodsId: &quot;00Y1kR4r1029X822731o0&quot;, isHost: 0, managerEarn: 0, postage: 10, profit: 0, specA: &quot;黑色&quot;, specB: &quot;128G&quot;, specC: &quot;小&quot;, specD: &quot;4.7寸&quot;, specE: &quot;套餐一&quot;, unionEarn: 0, vipPrice: 0 }, { c_id: 3136, costPrice: 0, discountPrice: 0, earn: 0, etime: null, flag: 0, goodsDetailCount: 199, goodsDetailId: &quot;100PgQ2xy08121409mY27&quot;, goodsDetailInventory: 199, goodsDetailOff: 0, goodsDetailPic: &quot;/upload/messageImage/1523281057461_Personal.jpg,/upload/messageImage/1523282906972_Personal.jpg,/upload/messageImage/1523283570897_Personal.jpg&quot;, goodsDetailPrice: 188, goodsDetailSpec: &quot;&quot;, goodsId: &quot;00Y1kR4r1029X822731o0&quot;, isHost: 0, managerEarn: 0, postage: 10, profit: 0, specA: &quot;蓝色&quot;, specB: &quot;64GG&quot;, specC: &quot;大&quot;, specD: &quot;4.5寸&quot;, specE: &quot;套餐二&quot;, unionEarn: 0, vipPrice: 0 }]; // var keys = { // &apos;颜色&apos;: [&apos;红色&apos;, &apos;白色&apos;], // &apos;容量&apos;: [&apos;8g&apos;, &apos;16g&apos;, &apos;32g&apos;, &apos;64g&apos;], // &apos;尺寸&apos;: [&apos;大&apos;, &apos;小&apos;, &apos;大&apos;], // &apos;套餐&apos;: [&apos;套餐一&apos;, &apos;套餐二&apos;, &apos;套餐三&apos;] // }; // //SKU，Stock Keeping Uint(库存量单位) // var sku_list = [{ // &apos;attrs&apos;: &apos;红色|16g|big|套餐二&apos;, // &apos;price&apos;: 120 // }, { // &apos;attrs&apos;: &apos;红色|8g|big|套餐一&apos;, // &apos;price&apos;: 10 // }, { // &apos;attrs&apos;: &apos;白色|16g|big|套餐二&apos;, // &apos;price&apos;: 28 // }, { // &apos;attrs&apos;: &apos;红色|64g|small|套餐三&apos;, // &apos;price&apos;: 220 // }, { // &apos;attrs&apos;: &apos;白色|32g|middle|套餐二&apos;, // &apos;price&apos;: 130 // }, { // &apos;attrs&apos;: &apos;红色|32g|big|套餐一&apos;, // &apos;price&apos;: 120 // }, ]; 实现：主要利用 Object.keys 方法获取对象的 key,value 值，配上 forEach 循环实现最终想要的结果。 var keys = {}; var sku_list = []; //原数据转换小写 goodsSpecJSON = goodsSpecJSON.map(function (keyo) { var key = Object.keys(keyo)[0]; var newkey = key.substring(0, 1).toLowerCase() + key.substring(1); var dic = {}; dic[newkey] = keyo[key]; return dic }); //生成keys goodsSpecJSON.forEach(function (keyo) { var key = Object.keys(keyo)[0]; //[&apos;specA&apos;] var val = keyo[key]; //颜色 if (!keys.hasOwnProperty(val)) { keys[val] = []; } var hash = {}; goodsSpecList.forEach(function (item, i) { if (hash[item[key]] === undefined) { hash[item[key]] = true; keys[val].push(item[key]); } // if (keys[val].indexOf(item[key]) === -1) { // keys[val].push(item[key]); // } }); }); console.log(keys) //生成sku_list goodsSpecList.forEach(function (item) { var dic = { attrs: &apos;&apos; }; goodsSpecJSON.forEach(function (keyo, j) { var key = Object.keys(keyo)[0]; dic.attrs += item[key] + (j === goodsSpecJSON.length - 1 ? &apos;&apos; : &apos;|&apos;); dic.price = item.goodsDetailPrice; dic.goodsDetailCount = item.goodsDetailCount; dic.goodsDetailId = item.goodsDetailId; }); sku_list.push(dic); }); console.log(sku_list) 输出结果：]]></content>
      <categories>
        <category>js</category>
        <category>Object.keys</category>
      </categories>
      <tags>
        <tag>Object.keys</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简洁的 Markdown 编辑器 Smark]]></title>
    <url>%2F2018%2F08%2F19%2FMarkdown%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[简洁的 Markdown 编辑器 Smark 说白了只是为了自己方便使用，并没什么新奇的东西。我使用 pandoc 来转化 markdown，但是我不想在修改文件时总是在编辑器、文字终端和浏览器间换来换去，因此我写了一个简单的编辑器，它在后台调用 pandoc 将当前编辑的 markdown 内容转化为 HTML，而后将 HTML 在 smark 中的浏览器中显示出来，就是这么回事。Smark 依赖于 pandoc、Qt 4.8 和 MathJax，在此向上述软件包开发者们致敬。请注意继承于 pandoc 的发布协议，Smark 同样遵循 GPL，如有任何疑问请联系 elerao.ao@gmail.com，我将尽快做出回复。 主要特性： Windows / Linux 等主流系统跨平台支持； 完美支持 LaTex 数学公式、脚注、尾注等，支持使用本地 MathJax 调用，不需要在线访问 MathJax CDN； 用户可配置的 Markdown 语法高亮显示，美观整洁； 多种格式文件导出支持，可将当前 Markdown 文件另存为 HTML、 Miscrosoft Word、OpenOffice / LibreOffice ODT Document、Latex、PDF、reStructured Text、Media Wiki markup、epub 以及 plain txt 等格式文件输出； 可通过用户指明 CSS 文件定义显示式样； 简洁友好的界面布局，尽可能地凸显正在编辑的内容； 系统、完备的各类快捷键，极大地提高了工作效率； 安装 Smark对于 Win32 平台的用户，您可以直接下载当前版本的可执行程序 Smark-X.X-Win32-portable.zip。对于其它平台的用户，可以下载当前版本的 Smark 源代码 Smark-X.X-src.zip在本平台上进行编译即可，一般地您可以按照如下步骤编译 Smark： 安装依赖的程序包: $ sudo apt-get install qtsdk $ sudo apt-get install pandoc 如果您不使用 apt-get 作为软件包管理器，自己谷歌搜索如何安装这两个程序包 下载 Smark 源代码 Smark-X.X-src.zip，解压并编译: $ qmake -project $ qmake $ make 把编译出的可执行文件移动到您的 [bin] 路径下即可使用，此时 Smark 将使用默认的 CSS 样式表和基于 MathJax CDN 的 MathJax 访问。如果想要得到与 Windows 平台下完全一致的体验，您还需下载 smark-2.0-resource.zip 解压倒 Smark 的安装目录下并进行设置。 运行截图Windows 7 下的 Smark 运行截图Windows 7 下的 Smark 配置选项对话框 FAQ64 位 Windows 下提示无法运行 pandoc：这是因为 Smark-X.X-Win32-portable.zip 中自带的 pandoc.exe 是 32 位系统下的，您可以通过下载安装包 pandoc-1.13.1-win64.msi 直接安装 64 位的 pandoc 而删除 Smark-X.X-Win32-portable.zip 中自带的 32 位的 pandoc.exe。 谷歌输入法无法输入问题貌似大凡使用 QTextEdit 部件的地方都存在这样的问题，这是因为您未开启 谷歌输入法的内嵌编辑模式，可通过点击 “谷歌输入法设置对话框” 中 “设置内嵌编辑模式” 按钮，后勾选 “使用内嵌编辑模式” 即可，如下图所示： TODO现有问题： 在 Qt5 下编译的 WebView 无法完整地加载 CSS 中的设置，Qt4 下没问题； 改动后的 Markdwon 语法高亮的超链接 和 加粗 的正则表达式匹配有问题； 导出 PDF 和打印时的内容分页问题； 待添加功能 仿照 QtCreator 3.1.xx 中编辑器的多行同时编辑实现，支持 Sublime 等软件所支持的多行同时编辑； 与 百度云、Google Drive、OneDrive 内容同步，这个以后再说； 附录：Smark 的快捷键列表 全局 Esc : 逐步隐藏所有不必要的部件，退出全屏显示 Tab : 增加所选诸行的缩进（四个空格） Ctrl + Tab : 减小所选诸行的缩进（四个空格） 文件菜单 Ctrl + N : 新建 markdown 文件 Ctrl + O : 打开 markdown 文件 Ctrl + S : 保存当前 markdown 文件 Ctrl + Shift + S : 将当前文件另存为支持的格式 Ctrl + W : 关闭当前 markdown 文件 Ctrl + P : 打印当前 markdown 文件 Ctrl + Q : 退出 Smark 视图菜单 F6 : 预览模式视图 F7 : 阅读模式视图 F8 : 编辑模式视图 F11 : 进入 / 退出全屏显示 编辑菜单 F5 : 刷新 HTML 显示 Ctrl + Shift + C : 查看 HTML 源代码 Ctrl + C : 复制 Ctrl + X : 剪切 Ctrl + P : 粘贴 Ctrl + Z : 撤消 Ctrl + Y : 重做 Ctrl + F : 查找 插入菜单 Ctrl + Shift + P : 插入图片 Ctrl + Shift + L : 插入链接 Ctrl + Shift + M : 插入数学公式 格式菜单 Ctrl + B : 加粗 Ctrl + I : 倾斜 Ctrl + U : 下划线 Ctrl + ] : 加大字号 Ctrl + [ : 减小字号 Ctrl + Down : 下标 Ctrl + Up : 上标 Ctrl + ` : 代码 Ctrl + &apos; : 引用 Ctrl + L : 内容左对齐 Ctrl + R : 内容右对齐 Ctrl + E : 内容居中]]></content>
      <categories>
        <category>工具类</category>
        <category>Smark</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
        <tag>Markdown</tag>
        <tag>Smark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>工具类</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F08%2F19%2F404%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
