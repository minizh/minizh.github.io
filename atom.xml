<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>minizh的个人网站</title>
  
  <subtitle>个人网站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-29T12:47:15.638Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>你就像谜一样</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js 遍历方法汇总</title>
    <link href="http://yoursite.com/2018/08/29/js%E9%81%8D%E5%8E%86%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2018/08/29/js遍历汇总/</id>
    <published>2018-08-29T12:47:55.000Z</published>
    <updated>2018-08-29T12:47:15.638Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-for-循环"><a href="#1-for-循环" class="headerlink" title="1. for 循环"></a>1. for 循环</h3><p>使用临时变量，将长度缓存起来，避免重复获取数组长度，当数组长度较大时，优化效果才会比较明显。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0, len = arr.length; i &lt; len; i++)&#123;</span><br><span class="line">//do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-es3-forEach-循环"><a href="#2-es3-forEach-循环" class="headerlink" title="2. es3 forEach 循环"></a>2. es3 forEach 循环</h3><p>遍历数组中的每一项，没有返回值，对原数组没有影响。</p><p><code>注意: forEach() 1.对于空数组是不会执行回调函数的； 2.且无法在所有元素都传递给调用的函数之前终止遍历。</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//1 没有返回值</span><br><span class="line">arr.forEach((item,index,array) =&gt; &#123;</span><br><span class="line">    //执行代码</span><br><span class="line">&#125;,this.value)</span><br><span class="line">//参数：item数组中的当前项, index当前项的索引, array原始数组；</span><br><span class="line">//this.value: 可选。传递给函数的值一般用 &quot;this&quot; 值。如果这个参数为空， &quot;undefined&quot; 会传递给 &quot;this&quot; 值</span><br><span class="line">//数组中有几项，那么传递进去的匿名回调函数就需要执行几次；</span><br></pre></td></tr></table></figure><h3 id="3-map-循环"><a href="#3-map-循环" class="headerlink" title="3. map 循环"></a>3. map 循环</h3><p>有返回值，可以 return 出来</p><p><strong>与 forEach 不同点：</strong></p><ol><li><p>forEach() 方法对数组的每个元素执行一次提供的函数。总是返回 undefined；</p></li><li><p>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。返回值是一个新的数组，并不影响原来的数组；</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">arr.map(function(value,index,array)&#123;</span><br><span class="line"></span><br><span class="line">　　//do something</span><br><span class="line"></span><br><span class="line">　　return XXX</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var ary = [12,23,24,42,1];</span><br><span class="line">var res = ary.map(function (item,index,ary ) &#123;</span><br><span class="line">    return item*10;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(res);//--&gt;[120,230,240,420,10];  原数组拷贝了一份，并进行了修改</span><br><span class="line">console.log(ary);//--&gt;[12,23,24,42,1]；  原数组并未发生变化</span><br></pre></td></tr></table></figure><h3 id="4-for…of-遍历"><a href="#4-for…of-遍历" class="headerlink" title="4. for…of 遍历"></a>4. for…of 遍历</h3><p>可以正确响应 break、continue 和 return 语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var value of myArray) &#123;</span><br><span class="line">console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>与 for…in 比较:</strong></p><p>用 for in 不仅可以对数组,也可以对 enumerable 对象操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var A = &#123;a:1,b:2,c:3,d:&quot;hello world&quot;&#125;;</span><br><span class="line">for(let k in A) &#123;</span><br><span class="line">    console.log(k,A[k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>总结来说:1.for in 总是得到对像的key或数组,字符串的下标，而 for of 和 forEach 一样，是直接得到值</code></p><p><code>2.for of 不能用于对象</code></p><h3 id="5-filter-遍历"><a href="#5-filter-遍历" class="headerlink" title="5. filter 遍历"></a>5. filter 遍历</h3><p>不会改变原始数组,返回新数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var arr = [</span><br><span class="line">  &#123; id: 1, text: &apos;aa&apos;, done: true &#125;,</span><br><span class="line">  &#123; id: 2, text: &apos;bb&apos;, done: false &#125;</span><br><span class="line">]</span><br><span class="line">console.log(arr.filter(item =&gt; item.done))</span><br><span class="line">//转为ES5</span><br><span class="line"></span><br><span class="line">arr.filter(function (item) &#123;</span><br><span class="line">  return item.done;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var arr = [73,84,56, 22,100]</span><br><span class="line">var newArr = arr.filter(item =&gt; item&gt;80)   //得到新数组 [84, 100]</span><br><span class="line">console.log(newArr,arr)</span><br></pre></td></tr></table></figure><h3 id="6-every-遍历"><a href="#6-every-遍历" class="headerlink" title="6. every 遍历"></a>6. every 遍历</h3><p>every()是对数组中的每一项运行给定函数，如果该函数对每一项返回 true,则返回 true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [ 1, 2, 3, 4, 5, 6 ];</span><br><span class="line">console.log( arr.every( function( item, index, array )&#123;</span><br><span class="line">        return item &gt; 3;</span><br><span class="line">    &#125;));</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h3 id="7-some-遍历"><a href="#7-some-遍历" class="headerlink" title="7. some 遍历"></a>7. some 遍历</h3><p>some()是对数组中每一项运行指定函数，如果该函数对任一项返回 true，则返回 true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [ 1, 2, 3, 4, 5, 6 ];</span><br><span class="line"></span><br><span class="line">    console.log( arr.some( function( item, index, array )&#123;</span><br><span class="line">        return item &gt; 3;</span><br><span class="line">    &#125;));</span><br><span class="line">true</span><br></pre></td></tr></table></figure><h3 id="8-reduce"><a href="#8-reduce" class="headerlink" title="8. reduce"></a>8. reduce</h3><p>reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var total = [0,1,2,3,4].reduce((a, b)=&gt;a + b); //10</span><br></pre></td></tr></table></figure><p>reduce 接受一个函数，函数有四个参数，分别是：上一次的值，当前值，当前值的索引，数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, index, array)&#123;</span><br><span class="line"> return previousValue + currentValue;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>reduce 还有第二个参数，我们可以把这个参数作为第一次调用 callback 时的第一个参数，上面这个例子因为没有第二个参数，所以直接从数组的第二项开始，如果我们给了第二个参数为 5，那么结果就是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, index, array)&#123;</span><br><span class="line"> return previousValue + currentValue;</span><br><span class="line">&#125;,5);</span><br></pre></td></tr></table></figure><p>第一次调用的 previousValue 的值就用传入的第二个参数代替，</p><h3 id="9-reduceRight"><a href="#9-reduceRight" class="headerlink" title="9. reduceRight"></a>9. reduceRight</h3><p>reduceRight()方法的功能和 reduce()功能是一样的，不同的是 reduceRight()从数组的末尾向前将数组中的数组项做累加。</p><p>reduceRight()首次调用回调函数 callbackfn 时，prevValue 和 curValue 可以是两个值之一。如果调用 reduceRight() 时提供了 initialValue 参数，则 prevValue 等于 initialValue，curValue 等于数组中的最后一个值。如果没有提供 initialValue 参数，则 prevValue 等于数组最后一个值， curValue 等于数组中倒数第二个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [0,1,2,3,4];</span><br><span class="line"></span><br><span class="line">arr.reduceRight(function (preValue,curValue,index,array) &#123;</span><br><span class="line">    return preValue + curValue;</span><br><span class="line">&#125;); // 10</span><br></pre></td></tr></table></figure><p>回调将会被调用四次，每次调用的参数及返回值如下：</p><p>如果提供一个初始值 initialValue 为 5:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [0,1,2,3,4];</span><br><span class="line"></span><br><span class="line">arr.reduceRight(function (preValue,curValue,index,array) &#123;</span><br><span class="line">    return preValue + curValue;</span><br><span class="line">&#125;, 5); // 15</span><br></pre></td></tr></table></figure><p>回调将会被调用五次，每次调用的参数及返回的值如下：</p><p>同样的，可以对一个数组求和，也可以使用 reduceRight()方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4,5,6];</span><br><span class="line"></span><br><span class="line">console.time(&quot;ruduceRight&quot;);</span><br><span class="line">Array.prototype.ruduceRightSum = function ()&#123;</span><br><span class="line">    for (var i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        return  this.reduceRight (function (preValue, curValue) &#123;</span><br><span class="line">            return preValue + curValue;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr.ruduceRightSum();</span><br><span class="line">console.log(&apos;最终的值：&apos; + arr.ruduceSum()); // 21</span><br><span class="line">console.timeEnd(&quot;ruduceRight&quot;); // 5.725ms</span><br></pre></td></tr></table></figure><h3 id="10-find"><a href="#10-find" class="headerlink" title="10. find"></a>10. find</h3><p>find()方法返回数组中符合测试函数条件的<strong><code>第一个</code></strong>元素。否则返回 undefined</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var stu = [</span><br><span class="line">    &#123;</span><br><span class="line">        name: &apos;张三&apos;,</span><br><span class="line">        gender: &apos;男&apos;,</span><br><span class="line">        age: 20</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &apos;王小毛&apos;,</span><br><span class="line">        gender: &apos;男&apos;,</span><br><span class="line">        age: 20</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &apos;李四&apos;,</span><br><span class="line">        gender: &apos;男&apos;,</span><br><span class="line">        age: 20</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">function getStu(element)&#123;</span><br><span class="line">   return element.name == &apos;李四&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stu.find(getStu)</span><br><span class="line">//返回结果为</span><br><span class="line">//&#123;name: &quot;李四&quot;, gender: &quot;男&quot;, age: 20&#125;</span><br></pre></td></tr></table></figure><p>ES6 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stu.find((element) =&gt; (element.name == &apos;李四&apos;))</span><br></pre></td></tr></table></figure><h3 id="11-findIndex"><a href="#11-findIndex" class="headerlink" title="11. findIndex"></a>11. findIndex</h3><p>对于数组中的每个元素，findIndex 方法都会调用一次回调函数（采用升序索引顺序），直到有元素返回 true。只要有一个元素返回 true，findIndex 立即返回该返回 true 的元素的索引值。如果数组中没有任何元素返回 true，则 findIndex 返回 -1。</p><p>findIndex 不会改变数组对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3].findIndex(function(x) &#123; x == 2; &#125;);</span><br><span class="line">// Returns an index value of 1.</span><br><span class="line"></span><br><span class="line">[1,2,3].findIndex(x =&gt; x == 4);</span><br><span class="line">// Returns an index value of -1.</span><br></pre></td></tr></table></figure><h3 id="12-keys，values，entries"><a href="#12-keys，values，entries" class="headerlink" title="12. keys，values，entries"></a>12. keys，values，entries</h3><p><code>ES6</code>提供一个新的方法 —— keys()，<code>ES8</code>又新增了两个方法 entries()和 values() —— 用于遍历数组。它们都返回一个遍历器对象，可以用 for…of 循环进行遍历，唯一的区别是 keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123;</span><br><span class="line">console.log(index);</span><br><span class="line">&#125;</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line">for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123;</span><br><span class="line">console.log(elem);</span><br><span class="line">&#125;</span><br><span class="line">// &apos;a&apos;</span><br><span class="line">// &apos;b&apos;</span><br><span class="line">for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123;</span><br><span class="line">console.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line">// 0 &quot;a&quot;</span><br><span class="line">// 1 &quot;b&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-for-循环&quot;&gt;&lt;a href=&quot;#1-for-循环&quot; class=&quot;headerlink&quot; title=&quot;1. for 循环&quot;&gt;&lt;/a&gt;1. for 循环&lt;/h3&gt;&lt;p&gt;使用临时变量，将长度缓存起来，避免重复获取数组长度，当数组长度较大时，优化效果才会比较明
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
      <category term="js遍历" scheme="http://yoursite.com/categories/js/js%E9%81%8D%E5%8E%86/"/>
    
    
      <category term="for of" scheme="http://yoursite.com/tags/for-of/"/>
    
      <category term="遍历数组" scheme="http://yoursite.com/tags/%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown语法总结</title>
    <link href="http://yoursite.com/2018/08/28/MarkDown%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/08/28/MarkDown语法总结/</id>
    <published>2018-08-28T12:19:15.000Z</published>
    <updated>2018-08-29T12:41:52.821Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h3><h4 id="a-一级标题"><a href="#a-一级标题" class="headerlink" title="a. 一级标题"></a>a. 一级标题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方式一： #1.一级标题</span><br><span class="line">方式二： 一级标题+分割线</span><br><span class="line">   =============</span><br></pre></td></tr></table></figure><h4 id="b-二级标题加分割线"><a href="#b-二级标题加分割线" class="headerlink" title="b. 二级标题加分割线"></a>b. 二级标题加分割线</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二级标题</span><br><span class="line">-------</span><br></pre></td></tr></table></figure><h4 id="c-1-6-标题："><a href="#c-1-6-标题：" class="headerlink" title="c. 1-6 标题："></a>c. 1-6 标题：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#1级标题</span><br><span class="line">##</span><br><span class="line">...</span><br><span class="line">### ### 6级标题</span><br></pre></td></tr></table></figure><h3 id="3-分割线"><a href="#3-分割线" class="headerlink" title="3. 分割线"></a>3. 分割线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*****</span><br><span class="line">-----</span><br></pre></td></tr></table></figure><h3 id="4-首行缩进"><a href="#4-首行缩进" class="headerlink" title="4. 首行缩进"></a>4. 首行缩进</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中文： &amp;emsp;</span><br><span class="line">英文： &amp;nbsp;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;段落的前后要有空行，所谓的空行<br> 是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。</p><h3 id="5-区块引用"><a href="#5-区块引用" class="headerlink" title="5. 区块引用"></a>5. 区块引用</h3><p>在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 区块引用</span><br><span class="line">&gt;&gt; 嵌套引用</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>区块引用</p><blockquote><p>嵌套引用</p></blockquote></blockquote><h3 id="6-代码区块"><a href="#6-代码区块" class="headerlink" title="6. 代码区块"></a>6. 代码区块</h3><p>代码区块的建立是在每行加上 4 个空格或者一个制表符（如同写代码一样）。<br>如普通段落：</p><p>首尾加制表符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Hello, Markdown.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>每行加四个空格 &lt; <em>首尾空需空行隔开</em> &gt;：</strong></p><pre><code>void main(){    printf(&quot;Hello, Markdown.&quot;);}&lt;div class=&quot;footer&quot;&gt;    © 2004 Foo Corporation&lt;/div&gt;</code></pre><h3 id="7-强调"><a href="#7-强调" class="headerlink" title="7. 强调"></a>7. 强调</h3><p>在强调内容两侧分别加上*或者_，如：</p><pre><code>*斜体*，_斜体_**粗体**，__粗体__</code></pre><p>效果：</p><p>_斜体_，_斜体_<br><strong>粗体</strong>，<strong>粗体</strong></p><h3 id="8-列表"><a href="#8-列表" class="headerlink" title="8. 列表"></a>8. 列表</h3><p>使用·、+、或-标记<strong>无序列表</strong>，如：</p><pre><code>-（+*） 第一项 -（+*） 第二项 - （+*）第三项</code></pre><p><em>`注意：标记后面最少有一个</em>空格<em>或</em>制表符<em>。若不在引用区块中，必须和前方段落之间存在空行。`</em></p><p>效果：</p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><p><strong>有序列表</strong>的标记方式是将上述的符号换成数字,并辅以.，如：</p><pre><code>1. 第一项2. 第二项3. 第三项</code></pre><p>效果：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="9-链接"><a href="#9-链接" class="headerlink" title="9.链接"></a>9.链接</h3><p>链接可以由两种形式生成：行内式和参考式。<br>行内式：</p><pre><code>[younghz的Markdown库](https://github.com/younghz/Markdown &quot;Markdown&quot;)。</code></pre><p>效果：</p><p><a href="https://github.com/younghz/Markdown" title="Markdown" target="_blank" rel="noopener">younghz 的 Markdown 库</a>。</p><p>参考式：</p><pre><code>[younghz的Markdown库1][1][younghz的Markdown库2][2][1]:https://github.com/younghz/Markdown &quot;Markdown&quot;[2]:https://github.com/younghz/Markdown &quot;Markdown&quot;</code></pre><p>效果：</p><p>[younghz 的 Markdown 库 1][1]<br>[younghz 的 Markdown 库 2][2]<br>[1]:<a href="https://github.com/younghz/Markdown" target="_blank" rel="noopener">https://github.com/younghz/Markdown</a> “Markdown”<br>[2]:<a href="https://github.com/younghz/Markdown" target="_blank" rel="noopener">https://github.com/younghz/Markdown</a> “Markdown”</p><blockquote><p>注意： 上述的[1]:https:://github.com/younghz/Markdown “Markdown”不出现在区块中</p></blockquote><h3 id="10-图片"><a href="#10-图片" class="headerlink" title="10. 图片"></a>10. 图片</h3><p>添加图片的形式和链接相似，只需在链接的基础上前方加一个！。</p><pre><code>![百度一下](https://www.baidu.com/img/bd_logo1.png &quot;百度一下&quot;)</code></pre><p><a href="http://www.baidu.com" target="_blank" rel="noopener"><img src="../../../../images/searchicon.png" alt="百度一下" title="百度一下"></a></p><h3 id="11-反斜杠"><a href="#11-反斜杠" class="headerlink" title="11. 反斜杠\"></a>11. 反斜杠\</h3><p>相当于反转义作用。使符号成为普通符号。</p><pre><code>\``\&amp;nbsp;</code></pre><p>效果：</p><p>``<br>\&nbsp;</p><h3 id="12-符号"><a href="#12-符号" class="headerlink" title="12. 符号 `"></a>12. 符号 `</h3><p>起到标记作用。如：</p><pre><code>`ctrl+a`</code></pre><p>效果：</p><p><code>ctrl+a</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-标题&quot;&gt;&lt;a href=&quot;#1-标题&quot; class=&quot;headerlink&quot; title=&quot;1. 标题&quot;&gt;&lt;/a&gt;1. 标题&lt;/h3&gt;&lt;h4 id=&quot;a-一级标题&quot;&gt;&lt;a href=&quot;#a-一级标题&quot; class=&quot;headerlink&quot; title=&quot;a. 
      
    
    </summary>
    
      <category term="工具类" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
      <category term="MarkDown语法" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/MarkDown%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="MarkDown基本语法总结" scheme="http://yoursite.com/tags/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>利用Object.keys遍历(forEach/map)对象数组，合并</title>
    <link href="http://yoursite.com/2018/08/20/objectKeys/"/>
    <id>http://yoursite.com/2018/08/20/objectKeys/</id>
    <published>2018-08-20T12:30:15.000Z</published>
    <updated>2018-08-19T09:48:36.605Z</updated>
    
    <content type="html"><![CDATA[<p>js 中几种遍历对象的方法，包括 for..of、for..in、Object.keys、Object.getOwnProperty,它们在使用场景方面各有不同。</p><p>js 对象的属性中可直接用、可访问到的属性分为数据属性和访问器属性。</p><h4 id="数据属性（实际存储属性值的属性）的四大特性："><a href="#数据属性（实际存储属性值的属性）的四大特性：" class="headerlink" title="数据属性（实际存储属性值的属性）的四大特性："></a>数据属性（实际存储属性值的属性）的四大特性：</h4><pre><code>{     value: 属性值,    writable: true/false,  //控制是否可修改    enumerable: true/false, //控制是否可被for in遍历    configurable: true/false, //1. 控制是否可删除 2. 控制是否可修改前两个特性  3.一旦改为false不可逆}</code></pre><h4 id="访问器属性（不实际存储数据，专门提供对其它数据-变量的保护）的四大特性："><a href="#访问器属性（不实际存储数据，专门提供对其它数据-变量的保护）的四大特性：" class="headerlink" title="访问器属性（不实际存储数据，专门提供对其它数据/变量的保护）的四大特性："></a>访问器属性（不实际存储数据，专门提供对其它数据/变量的保护）的四大特性：</h4><pre><code>{    get:function(){return this.隐藏属性;},    set:function(val){    //如果val符合条件        this.隐藏属性=val    //否则        报错},enumerable, configurable}</code></pre><h3 id="1-for-in"><a href="#1-for-in" class="headerlink" title="1. for..in"></a>1. for..in</h3><hr><p>返回的是所有能够通过对象访问的、可枚举的属性，既包括存在于实例中的属性，也包括存在于原型中的实例,不能保证属性按对象原来的顺序输出。（可枚举-自身-原型）</p><pre><code>var obj = {a:1, b:2, c:3};for (var prop in obj) {  console.log(&quot;obj.&quot; + prop + &quot; = &quot; + obj[prop]);}// Output:// &quot;obj.a = 1&quot;// &quot;obj.b = 2&quot;// &quot;obj.c = 3&quot;</code></pre><h3 id="2-Object-keys"><a href="#2-Object-keys" class="headerlink" title="2. Object.keys"></a>2. Object.keys</h3><hr><p>用于获取对象自身所有的可枚举的属性值，但不包括原型中的属性，然后返回一个由属性名组成的数组。注意它同 for..in 一样不能保证属性按对象原来的顺序输出。（可枚举-自身）</p><pre><code>// 数组var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];console.log(Object.keys(arr)); // console: [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;]// 类数组对象var obj = { 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos; };console.log(Object.keys(obj)); // console: [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;]// 类数组对象-随机下标var anObj = { 100: &apos;a&apos;, 2: &apos;b&apos;, 7: &apos;c&apos; };console.log(Object.keys(anObj)); // console: [&apos;2&apos;, &apos;7&apos;, &apos;100&apos;]// 不可枚举属性getFoovar myObj = Object.create({}, {  getFoo: {value: function () { return this.foo; }  }});myObj.foo = 1;console.log(Object.keys(myObj)); // console: [&apos;foo&apos;]</code></pre><h3 id="3-Object-getOwnProperty"><a href="#3-Object-getOwnProperty" class="headerlink" title="3. Object.getOwnProperty"></a>3. Object.getOwnProperty</h3><hr><p>如果你想获取一个对象的所有属性，甚至包括不可枚举的，则可用该方法。其返回对象的所有自身属性的属性名组成的数组，但不会获取原型链上的属性。（可枚举&amp;不可枚举-自身）</p><pre><code>//获取不可枚举属性var my_obj = Object.create({}, {  getFoo: {value: function() { return this.foo; },enumerable: false  }});my_obj.foo = 1;console.log(Object.getOwnPropertyNames(my_obj).sort()); // [&quot;foo&quot;, &quot;getFoo&quot;]</code></pre><p>下面的例子演示了该方法不会获取到原型链上的属性：</p><pre><code>function ParentClass() {}ParentClass.prototype.inheritedMethod = function() {};function ChildClass() {  this.prop = 5;  this.method = function() {};}ChildClass.prototype = new ParentClass;ChildClass.prototype.prototypeMethod = function() {};console.log(  Object.getOwnPropertyNames(new ChildClass()  // [&quot;prop&quot;, &quot;method&quot;]  ));</code></pre><h3 id="4-for-of"><a href="#4-for-of" class="headerlink" title="4. for..of"></a>4. for..of</h3><hr><p>es6 新增方法，主要来遍历可迭代的对象（包括 Array, Map, Set, arguments 等），它主要用来获取对象 value 值，而 for..in 主要获取对象 key 值。<br>另外：可以由 break, continue, throw 或 return 终止。在这些情况下，迭代器关闭。</p><pre><code>let iterable = [10, 20, 30];for (let value of iterable) {value += 1;console.log(value);}// 11// 21// 31</code></pre><p>与 for..in 循环之间的区别：</p><pre><code>Object.prototype.objCustom = function() {};Array.prototype.arrCustom = function() {};let iterable = [3, 5, 7];iterable.foo = &apos;hello&apos;;for (let i in iterable) {  console.log(i); //  0, 1, 2, &quot;foo&quot;, &quot;arrCustom&quot;, &quot;objCustom&quot;}for (let i in iterable) {  if (iterable.hasOwnProperty(i)) {console.log(i); //  0, 1, 2, &quot;foo&quot;  }}for (let i of iterable) {  console.log(i); //  3, 5, 7}</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>其实这几个方法之间的差异主要在属性是否可可枚举，是来自原型，还是实例。<br>图片描述</p><p>开发中的实际应用<br>需求：将如下两个从后台不同端口获取的 json 对象数组整合处理成如下注释部分的 json 对象</p><pre><code>var goodsSpecJSON = [{&quot;SpecA&quot;: &quot;颜色&quot;}, {&quot;SpecB&quot;: &quot;容量&quot;}, {&quot;SpecC&quot;: &quot;大小&quot;}, {&quot;SpecD&quot;: &quot;尺寸&quot;}, {&quot;SpecE&quot;: &quot;套餐&quot;}];var goodsSpecList = [{c_id: 3133,costPrice: 0,discountPrice: 0,earn: 0,etime: null,flag: 0,goodsDetailCount: 199,goodsDetailId: &quot;100PgQ2xy08121409mY27&quot;,goodsDetailInventory: 199,goodsDetailOff: 0,goodsDetailPic: &quot;/upload/messageImage/1523281057461_Personal.jpg,/upload/messageImage/1523282906972_Personal.jpg,/upload/messageImage/1523283570897_Personal.jpg&quot;,goodsDetailPrice: 188,goodsDetailSpec: &quot;&quot;,goodsId: &quot;00Y1kR4r1029X822731o0&quot;,isHost: 0,managerEarn: 0,postage: 10,profit: 0,specA: &quot;红色&quot;,specB: &quot;32G&quot;,specC: &quot;小&quot;,specD: &quot;4.7寸&quot;,specE: &quot;套餐一&quot;,unionEarn: 0,vipPrice: 0}, {c_id: 3134,costPrice: 0,discountPrice: 0,earn: 0,etime: null,flag: 0,goodsDetailCount: 199,goodsDetailId: &quot;100PgQ2xy08121409mY27&quot;,goodsDetailInventory: 199,goodsDetailOff: 0,goodsDetailPic: &quot;/upload/messageImage/1523281057461_Personal.jpg,/upload/messageImage/1523282906972_Personal.jpg,/upload/messageImage/1523283570897_Personal.jpg&quot;,goodsDetailPrice: 188,goodsDetailSpec: &quot;&quot;,goodsId: &quot;00Y1kR4r1029X822731o0&quot;,isHost: 0,managerEarn: 0,postage: 10,profit: 0,specA: &quot;白色&quot;,specB: &quot;64G&quot;,specC: &quot;小&quot;,specD: &quot;5寸&quot;,specE: &quot;套餐二&quot;,unionEarn: 0,vipPrice: 0}, {c_id: 3135,costPrice: 0,discountPrice: 0,earn: 0,etime: null,flag: 0,goodsDetailCount: 199,goodsDetailId: &quot;100PgQ2xy08121409mY27&quot;,goodsDetailInventory: 199,goodsDetailOff: 0,goodsDetailPic: &quot;/upload/messageImage/1523281057461_Personal.jpg,/upload/messageImage/1523282906972_Personal.jpg,/upload/messageImage/1523283570897_Personal.jpg&quot;,goodsDetailPrice: 188,goodsDetailSpec: &quot;&quot;,goodsId: &quot;00Y1kR4r1029X822731o0&quot;,isHost: 0,managerEarn: 0,postage: 10,profit: 0,specA: &quot;黑色&quot;,specB: &quot;128G&quot;,specC: &quot;小&quot;,specD: &quot;4.7寸&quot;,specE: &quot;套餐一&quot;,unionEarn: 0,vipPrice: 0}, {c_id: 3136,costPrice: 0,discountPrice: 0,earn: 0,etime: null,flag: 0,goodsDetailCount: 199,goodsDetailId: &quot;100PgQ2xy08121409mY27&quot;,goodsDetailInventory: 199,goodsDetailOff: 0,goodsDetailPic: &quot;/upload/messageImage/1523281057461_Personal.jpg,/upload/messageImage/1523282906972_Personal.jpg,/upload/messageImage/1523283570897_Personal.jpg&quot;,goodsDetailPrice: 188,goodsDetailSpec: &quot;&quot;,goodsId: &quot;00Y1kR4r1029X822731o0&quot;,isHost: 0,managerEarn: 0,postage: 10,profit: 0,specA: &quot;蓝色&quot;,specB: &quot;64GG&quot;,specC: &quot;大&quot;,specD: &quot;4.5寸&quot;,specE: &quot;套餐二&quot;,unionEarn: 0,vipPrice: 0}];// var keys = {// &apos;颜色&apos;: [&apos;红色&apos;, &apos;白色&apos;],// &apos;容量&apos;: [&apos;8g&apos;, &apos;16g&apos;, &apos;32g&apos;, &apos;64g&apos;],// &apos;尺寸&apos;: [&apos;大&apos;, &apos;小&apos;, &apos;大&apos;],// &apos;套餐&apos;: [&apos;套餐一&apos;, &apos;套餐二&apos;, &apos;套餐三&apos;]// };// //SKU，Stock Keeping Uint(库存量单位)// var sku_list = [{// &apos;attrs&apos;: &apos;红色|16g|big|套餐二&apos;,// &apos;price&apos;: 120// }, {// &apos;attrs&apos;: &apos;红色|8g|big|套餐一&apos;,// &apos;price&apos;: 10// }, {// &apos;attrs&apos;: &apos;白色|16g|big|套餐二&apos;,// &apos;price&apos;: 28// }, {// &apos;attrs&apos;: &apos;红色|64g|small|套餐三&apos;,// &apos;price&apos;: 220// }, {// &apos;attrs&apos;: &apos;白色|32g|middle|套餐二&apos;,// &apos;price&apos;: 130// }, {// &apos;attrs&apos;: &apos;红色|32g|big|套餐一&apos;,// &apos;price&apos;: 120// }, ];</code></pre><p>实现：主要利用 Object.keys 方法获取对象的 key,value 值，配上 forEach 循环实现最终想要的结果。</p><pre><code>var keys = {};var sku_list = [];//原数据转换小写goodsSpecJSON = goodsSpecJSON.map(function (keyo) {var key = Object.keys(keyo)[0];var newkey = key.substring(0, 1).toLowerCase() + key.substring(1);var dic = {};dic[newkey] = keyo[key];return dic});//生成keysgoodsSpecJSON.forEach(function (keyo) {var key = Object.keys(keyo)[0]; //[&apos;specA&apos;]var val = keyo[key]; //颜色if (!keys.hasOwnProperty(val)) {keys[val] = [];}var hash = {};goodsSpecList.forEach(function (item, i) {if (hash[item[key]] === undefined) {hash[item[key]] = true;keys[val].push(item[key]);}// if (keys[val].indexOf(item[key]) === -1) {// keys[val].push(item[key]);// }});});console.log(keys)//生成sku_listgoodsSpecList.forEach(function (item) {var dic = {attrs: &apos;&apos;};goodsSpecJSON.forEach(function (keyo, j) {var key = Object.keys(keyo)[0];dic.attrs += item[key] + (j === goodsSpecJSON.length - 1 ? &apos;&apos; : &apos;|&apos;);dic.price = item.goodsDetailPrice;dic.goodsDetailCount = item.goodsDetailCount;dic.goodsDetailId = item.goodsDetailId;});sku_list.push(dic);});console.log(sku_list)</code></pre><p>输出结果：</p><p><img src="https://i.imgur.com/gOOuYv0.png" alt="示例结果"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;js 中几种遍历对象的方法，包括 for..of、for..in、Object.keys、Object.getOwnProperty,它们在使用场景方面各有不同。&lt;/p&gt;
&lt;p&gt;js 对象的属性中可直接用、可访问到的属性分为数据属性和访问器属性。&lt;/p&gt;
&lt;h4 id=&quot;数
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
      <category term="Object.keys" scheme="http://yoursite.com/categories/js/Object-keys/"/>
    
    
      <category term="Object.keys" scheme="http://yoursite.com/tags/Object-keys/"/>
    
      <category term="遍历" scheme="http://yoursite.com/tags/%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>简洁的 Markdown 编辑器 Smark</title>
    <link href="http://yoursite.com/2018/08/19/Markdown%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>http://yoursite.com/2018/08/19/Markdown编辑器/</id>
    <published>2018-08-19T13:05:15.000Z</published>
    <updated>2018-08-19T09:48:51.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简洁的-Markdown-编辑器-Smark"><a href="#简洁的-Markdown-编辑器-Smark" class="headerlink" title="简洁的 Markdown 编辑器 Smark"></a>简洁的 Markdown 编辑器 Smark</h1><p><img align="left" src="https://raw.githubusercontent.com/elerao/Smark/master/README/logo.png" width="100"></p><p>说白了只是为了自己方便使用，并没什么新奇的东西。我使用 <a href="http://johnmacfarlane.net/pandoc/" target="_blank" rel="noopener">pandoc</a> 来转化 <code>markdown</code>，但是我不想在修改文件时总是在编辑器、文字终端和浏览器间换来换去，因此我写了一个简单的编辑器，它在后台调用 <code>pandoc</code> 将当前编辑的 <code>markdown</code> 内容转化为 <code>HTML</code>，而后将 <code>HTML</code> 在 <code>smark</code> 中的浏览器中显示出来，就是这么回事。Smark 依赖于 <a href="http://johnmacfarlane.net/pandoc/" target="_blank" rel="noopener"><code>pandoc</code></a>、<a href="http://qt-project.org/" target="_blank" rel="noopener"><code>Qt 4.8</code></a> 和 <a href="http://www.mathjax.org" target="_blank" rel="noopener"><code>MathJax</code></a>，在此向上述软件包开发者们致敬。请注意继承于 pandoc 的发布协议，Smark 同样遵循 <a href="http://www.gnu.org/copyleft/gpl.html" target="_blank" rel="noopener">GPL</a>，如有任何疑问请联系 <a href="elerao.ao@gmail.com">elerao.ao@gmail.com</a>，我将尽快做出回复。</p><p>主要特性：</p><ul><li><code>Windows</code> / <code>Linux</code> 等主流系统跨平台支持；</li><li>完美支持 <code>LaTex</code> 数学公式、脚注、尾注等，支持使用本地 <code>MathJax</code> 调用，不需要在线访问 <code>MathJax CDN</code>；</li><li>用户可配置的 <code>Markdown</code> 语法高亮显示，美观整洁；</li><li>多种格式文件导出支持，可将当前 <code>Markdown</code> 文件另存为 <code>HTML</code>、 <code>Miscrosoft Word</code>、<code>OpenOffice / LibreOffice ODT Document</code>、<code>Latex</code>、<code>PDF</code>、<code>reStructured Text</code>、<code>Media Wiki markup</code>、<code>epub</code> 以及 <code>plain txt</code> 等格式文件输出；</li><li>可通过用户指明 <code>CSS</code> 文件定义显示式样；</li><li>简洁友好的界面布局，尽可能地凸显正在编辑的内容；</li><li>系统、完备的各类快捷键，极大地提高了工作效率；</li></ul><h2 id="安装-Smark"><a href="#安装-Smark" class="headerlink" title="安装 Smark"></a>安装 Smark</h2><p>对于 <code>Win32</code> 平台的用户，您可以直接下载当前版本的可执行程序 <a href="http://pan.baidu.com/s/1ntMCVFV" target="_blank" rel="noopener">Smark-X.X-Win32-portable.zip</a>。对于其它平台的用户，可以下载当前版本的 Smark 源代码 <a href="http://pan.baidu.com/s/1ntMCVFV" target="_blank" rel="noopener">Smark-X.X-src.zip</a>在本平台上进行编译即可，一般地您可以按照如下步骤编译 <code>Smark</code>：</p><ol><li><p>安装依赖的程序包:</p><pre><code>$ sudo apt-get install qtsdk$ sudo apt-get install pandoc</code></pre><p>如果您不使用 <code>apt-get</code> 作为软件包管理器，自己谷歌搜索如何安装这两个程序包</p></li><li><p>下载 Smark 源代码 <a href="http://pan.baidu.com/s/1ntMCVFV" target="_blank" rel="noopener">Smark-X.X-src.zip</a>，解压并编译:</p><pre><code>$ qmake -project$ qmake$ make</code></pre></li><li><p>把编译出的可执行文件移动到您的 <code>[bin]</code> 路径下即可使用，此时 <code>Smark</code> 将使用默认的 <code>CSS</code> 样式表和基于 <code>MathJax CDN</code> 的 <code>MathJax</code> 访问。如果想要得到与 <code>Windows</code> 平台下完全一致的体验，您还需下载 <a href="http://pan.baidu.com/s/1ntMCVFV" target="_blank" rel="noopener">smark-2.0-resource.zip</a> 解压倒 <code>Smark</code> 的安装目录下并进行设置。</p></li></ol><h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p align="center"><br><br><img src="https://raw.githubusercontent.com/elerao/Smark/master/README/screenshot.png" width="95%"><br><br>Windows 7 下的 Smark 运行截图<br><br><br><br><img src="https://raw.githubusercontent.com/elerao/Smark/master/README/option-dialog.png" width="95%"><br><br>Windows 7 下的 Smark 配置选项对话框<br></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="64-位-Windows-下提示无法运行-pandoc："><a href="#64-位-Windows-下提示无法运行-pandoc：" class="headerlink" title="64 位 Windows 下提示无法运行 pandoc："></a>64 位 Windows 下提示无法运行 pandoc：</h3><p>这是因为 <a href="http://pan.baidu.com/s/1ntMCVFV" target="_blank" rel="noopener">Smark-X.X-Win32-portable.zip</a> 中自带的 pandoc.exe 是 32 位系统下的，您可以通过下载安装包 <a href="http://pan.baidu.com/s/1ntMCVFV#path=%252Fsmark" target="_blank" rel="noopener">pandoc-1.13.1-win64.msi</a> 直接安装 64 位的 <code>pandoc</code> 而删除 <a href="http://pan.baidu.com/s/1ntMCVFV" target="_blank" rel="noopener">Smark-X.X-Win32-portable.zip</a> 中自带的 32 位的 <code>pandoc.exe</code>。</p><h3 id="谷歌输入法无法输入问题"><a href="#谷歌输入法无法输入问题" class="headerlink" title="谷歌输入法无法输入问题"></a>谷歌输入法无法输入问题</h3><p>貌似大凡使用 <code>QTextEdit</code> 部件的地方都存在这样的问题，这是因为您未开启 谷歌输入法的内嵌编辑模式，可通过点击 “谷歌输入法设置对话框” 中 “设置内嵌编辑模式” 按钮，后勾选 “使用内嵌编辑模式” 即可，如下图所示：</p><p align="center"><br><br><img src="https://raw.githubusercontent.com/elerao/Smark/master/README/google-input-setting.png" width="60%"><br></p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h3 id="现有问题："><a href="#现有问题：" class="headerlink" title="现有问题："></a>现有问题：</h3><ul><li>在 Qt5 下编译的 WebView 无法完整地加载 CSS 中的设置，Qt4 下没问题；</li><li>改动后的 Markdwon 语法高亮的超链接 和 加粗 的正则表达式匹配有问题；</li><li>导出 PDF 和打印时的内容分页问题；</li></ul><h3 id="待添加功能"><a href="#待添加功能" class="headerlink" title="待添加功能"></a>待添加功能</h3><ul><li>仿照 QtCreator 3.1.xx 中编辑器的多行同时编辑实现，支持 Sublime 等软件所支持的多行同时编辑；</li><li>与 百度云、Google Drive、OneDrive 内容同步，这个以后再说；</li></ul><h2 id="附录：Smark-的快捷键列表"><a href="#附录：Smark-的快捷键列表" class="headerlink" title="附录：Smark 的快捷键列表"></a>附录：Smark 的快捷键列表</h2><p id="hotkey"></p><p>全局</p><pre><code>Esc              : 逐步隐藏所有不必要的部件，退出全屏显示Tab              : 增加所选诸行的缩进（四个空格）Ctrl + Tab       : 减小所选诸行的缩进（四个空格）</code></pre><p>文件菜单</p><pre><code>Ctrl + N         : 新建 markdown 文件Ctrl + O         : 打开 markdown 文件Ctrl + S         : 保存当前 markdown 文件Ctrl + Shift + S : 将当前文件另存为支持的格式Ctrl + W         : 关闭当前 markdown 文件Ctrl + P         : 打印当前 markdown 文件Ctrl + Q         : 退出 Smark</code></pre><p>视图菜单</p><pre><code>F6               : 预览模式视图F7               : 阅读模式视图F8               : 编辑模式视图F11              : 进入 / 退出全屏显示</code></pre><p>编辑菜单</p><pre><code>F5               : 刷新 HTML 显示Ctrl + Shift + C : 查看 HTML 源代码Ctrl + C         : 复制Ctrl + X         : 剪切Ctrl + P         : 粘贴Ctrl + Z         : 撤消Ctrl + Y         : 重做Ctrl + F         : 查找</code></pre><p>插入菜单</p><pre><code>Ctrl + Shift + P : 插入图片Ctrl + Shift + L : 插入链接Ctrl + Shift + M : 插入数学公式</code></pre><p>格式菜单</p><pre><code>Ctrl + B         : 加粗Ctrl + I         : 倾斜Ctrl + U         : 下划线Ctrl + ]         : 加大字号Ctrl + [         : 减小字号Ctrl + Down      : 下标Ctrl + Up        : 上标Ctrl + `         : 代码Ctrl + &apos;         : 引用Ctrl + L         : 内容左对齐Ctrl + R         : 内容右对齐Ctrl + E         : 内容居中</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简洁的-Markdown-编辑器-Smark&quot;&gt;&lt;a href=&quot;#简洁的-Markdown-编辑器-Smark&quot; class=&quot;headerlink&quot; title=&quot;简洁的 Markdown 编辑器 Smark&quot;&gt;&lt;/a&gt;简洁的 Markdown 编辑器 Sma
      
    
    </summary>
    
      <category term="工具类" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
      <category term="Smark" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/Smark/"/>
    
    
      <category term="编辑器" scheme="http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
      <category term="Smark" scheme="http://yoursite.com/tags/Smark/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/08/19/hello-world/"/>
    <id>http://yoursite.com/2018/08/19/hello-world/</id>
    <published>2018-08-19T11:35:15.000Z</published>
    <updated>2018-08-19T09:48:19.925Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="工具类" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
      <category term="hexo" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/08/19/404/"/>
    <id>http://yoursite.com/2018/08/19/404/</id>
    <published>2018-08-19T09:42:18.623Z</published>
    <updated>2018-08-19T09:47:59.820Z</updated>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML><html><head>    <meta http-equiv="content-type" content="text/html;charset=utf-8;">    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    <meta name="robots" content="all">    <meta name="robots" content="index,follow">    <link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"></head><body>    <script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homepageurl="/" homepagename="回到我的主页">  </script>    <script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"></script>    <script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"></script></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!DOCTYPE HTML&gt;
&lt;html&gt;

&lt;head&gt;
    &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible
      
    
    </summary>
    
    
  </entry>
  
</feed>
