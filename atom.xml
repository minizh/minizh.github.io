<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>I&#39;m Minizh</title>
  
  <subtitle>ZH的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-09T11:06:37.637Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>你就像谜一样</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6小技巧</title>
    <link href="http://yoursite.com/2018/10/05/ES6%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2018/10/05/ES6小技巧/</id>
    <published>2018-10-05T13:28:10.000Z</published>
    <updated>2018-10-09T11:06:37.637Z</updated>
    
    <content type="html"><![CDATA[<p><code>摘要：总结ES6新特性：默认参数、reduce、解构赋值和Set在使用时的一些小技巧。</code></p><p>ES6出来已经有好几年了，同时很多新特性可以被巧妙地运用在项目中。我想要列下其中一些，希望它们对你有用。    </p><p>如果你还知道其他一些小技巧，欢迎留言。我很高兴把它们补充进来。</p><h3 id="1-强制要求参数"><a href="#1-强制要求参数" class="headerlink" title="1. 强制要求参数"></a>1. 强制要求参数</h3><p><strong><code>ES6</code></strong>提供了默认参数值机制，允许你为参数设置默认值，防止函数在调用时没有传入这些参数。</p><p>在下面的例子中，我们写了一个required()函数作为参数a和b的默认值。<br>这意味着如果a或b其中有一个参数没有在调用时传值，会默认required()函数，然后抛出错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const required = () =&gt; &#123;throw new Error(&apos;Missing parameter&apos;)&#125;;</span><br><span class="line">const add = (a = required(), b = required()) =&gt; a + b;</span><br><span class="line">add(1, 2) //3</span><br><span class="line">add(1) // Error: Missing parameter.</span><br></pre></td></tr></table></figure></p><h3 id="2-强大的reduce"><a href="#2-强大的reduce" class="headerlink" title="2. 强大的reduce"></a>2. 强大的reduce</h3><p>数组的reduce方法用途很广。它一般被用来把数组中每一项规约到单个值。但是你可以利用它做更多的事。</p><h4 id="2-1-使用reduce同时实现map和filter"><a href="#2-1-使用reduce同时实现map和filter" class="headerlink" title="2.1 使用reduce同时实现map和filter"></a>2.1 使用reduce同时实现map和filter</h4><p>假设现在有一个数列，你希望更新它的每一项（map的功能）然后筛选出一部分（filter的功能）。如果是先使用map然后filter的话，你需要遍历这个数组两次。</p><p>在下面的代码中，我们将数列中的值翻倍，然后挑选出那些大于50的数。有注意到我们是如何非常高效地使用reduce来同时完成map和filter方法的吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [10, 20, 30, 40];</span><br><span class="line">const doubledOver50 = numbers.reduce((finalList, num) =&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  num = num * 2; </span><br><span class="line">  </span><br><span class="line">  if (num &gt; 50) &#123;</span><br><span class="line">    finalList.push(num);</span><br><span class="line">  &#125;</span><br><span class="line">  return finalList;</span><br><span class="line">&#125;, []);</span><br><span class="line">doubledOver50; // [60, 80]</span><br></pre></td></tr></table></figure><p><code>关于reduce参数说明及一些高级操作</code><a href="https://segmentfault.com/a/1190000005921341" title="reduce" target="_blank" rel="noopener">数组reduce方法的高级技巧</a> 。</p><h4 id="2-2-使用reduce匹配圆括号"><a href="#2-2-使用reduce匹配圆括号" class="headerlink" title="2.2 使用reduce匹配圆括号"></a>2.2 使用reduce匹配圆括号</h4><p>reduce的另外一个用途是能够匹配给定字符串中的圆括号。对于一个含有圆括号的字符串，我们需要知道(和)的数量是否一致，并且(是否出现在)之前。</p><p>下面的代码中我们使用reduce可以轻松地解决这个问题。我们只需要先声明一个counter变量，初值为0。在遇到(时counter加一，遇到)时counter减一。如果左右括号数目匹配，那最终结果为0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//Returns 0 if balanced.</span><br><span class="line">const isParensBalanced = (str) =&gt; &#123;</span><br><span class="line">  return str.split(&apos;&apos;).reduce((counter, char) =&gt; &#123;</span><br><span class="line">    if(counter &lt; 0) &#123; //matched &quot;)&quot; before &quot;(&quot;</span><br><span class="line">      return counter;</span><br><span class="line">    &#125; else if(char === &apos;(&apos;) &#123;</span><br><span class="line">      return ++counter;</span><br><span class="line">    &#125; else if(char === &apos;)&apos;) &#123;</span><br><span class="line">      return --counter;</span><br><span class="line">    &#125;  else &#123; //matched some other char</span><br><span class="line">      return counter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;, 0); //&lt;-- starting value of the counter</span><br><span class="line">&#125;</span><br><span class="line">isParensBalanced(&apos;(())&apos;) // 0 &lt;-- balanced</span><br><span class="line">isParensBalanced(&apos;(asdfds)&apos;) //0 &lt;-- balanced</span><br><span class="line">isParensBalanced(&apos;(()&apos;) // 1 &lt;-- not balanced</span><br><span class="line">isParensBalanced(&apos;)(&apos;) // -1 &lt;-- not balanced</span><br></pre></td></tr></table></figure></p><h4 id="2-3-统计数组中相同项的个数"><a href="#2-3-统计数组中相同项的个数" class="headerlink" title="2.3 统计数组中相同项的个数"></a>2.3 统计数组中相同项的个数</h4><p>很多时候，你希望统计数组中重复出现项的个数然后用一个对象表示。那么你可以使用reduce方法处理这个数组。</p><p>下面的代码将统计每一种车的数目然后把总数用一个对象表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var cars = [&apos;BMW&apos;,&apos;Benz&apos;, &apos;Benz&apos;, &apos;Tesla&apos;, &apos;BMW&apos;, &apos;Toyota&apos;];</span><br><span class="line">var carsObj = cars.reduce(function (obj, name) &#123; </span><br><span class="line">   obj[name] = obj[name] ? ++obj[name] : 1;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line">carsObj; // =&gt; &#123; BMW: 2, Benz: 2, Tesla: 1, Toyota: 1 &#125;</span><br><span class="line">reduce的其他用处实在是太多了，我建议你阅读MDN的相关代码示例。</span><br></pre></td></tr></table></figure></p><h3 id="3-对象解构"><a href="#3-对象解构" class="headerlink" title="3. 对象解构"></a>3. 对象解构</h3><h4 id="3-1-删除不需要的属性"><a href="#3-1-删除不需要的属性" class="headerlink" title="3.1 删除不需要的属性"></a>3.1 删除不需要的属性</h4><p>有时候你不希望保留某些对象属性，也许是因为它们包含敏感信息或仅仅是太大了（just too big）。你可能会枚举整个对象然后删除它们，但实际上只需要简单的将这些无用属性赋值给变量，然后把想要保留的有用部分作为剩余参数就可以了。</p><p>下面的代码里，我们希望删除_internal和tooBig参数。我们可以把它们赋值给internal和tooBig变量，然后在cleanObject中存储剩下的属性以备后用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let &#123;_internal, tooBig, ...cleanObject&#125; = &#123;el1: &apos;1&apos;, _internal:&quot;secret&quot;, tooBig:&#123;&#125;, el2: &apos;2&apos;, el3: &apos;3&apos;&#125;;</span><br><span class="line">console.log(cleanObject); // &#123;el1: &apos;1&apos;, el2: &apos;2&apos;, el3: &apos;3&apos;&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-2-在函数参数中解构嵌套对象"><a href="#3-2-在函数参数中解构嵌套对象" class="headerlink" title="3.2 在函数参数中解构嵌套对象"></a>3.2 在函数参数中解构嵌套对象</h4><p>在下面的代码中，engine是对象car中嵌套的一个对象。如果我们对engine的vin属性感兴趣，使用解构赋值可以很轻松地得到它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var car = &#123;</span><br><span class="line">  model: &apos;bmw 2018&apos;,</span><br><span class="line">  engine: &#123;</span><br><span class="line">    v6: true,</span><br><span class="line">    turbo: true,</span><br><span class="line">    vin: 12345</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const modelAndVIN = (&#123;model, engine: &#123;vin&#125;&#125;) =&gt; &#123;</span><br><span class="line">  console.log(`model: $&#123;model&#125; vin: $&#123;vin&#125;`);</span><br><span class="line">&#125;</span><br><span class="line">modelAndVIN(car); // =&gt; model: bmw 2018  vin: 12345</span><br></pre></td></tr></table></figure></p><h4 id="3-3-合并对象"><a href="#3-3-合并对象" class="headerlink" title="3.3 合并对象"></a>3.3 合并对象</h4><p>ES6带来了扩展运算符（…）。它一般被用来解构数组，但你也可以用它处理对象。</p><p>接下来，我们使用扩展运算符来展开一个新的对象，第二个对象中的属性值会改写第一个对象的属性值。比如object2的b和c就会改写object1的同名属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let object1 = &#123; a:1, b:2,c:3 &#125;</span><br><span class="line">let object2 = &#123; b:30, c:40, d:50&#125;</span><br><span class="line">let merged = &#123;…object1, …object2&#125; //spread and re-add into merged</span><br><span class="line">console.log(merged) // &#123;a:1, b:30, c:40, d:50&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-Sets"><a href="#4-Sets" class="headerlink" title="4. Sets"></a>4. Sets</h3><h4 id="4-1-使用Set实现数组去重"><a href="#4-1-使用Set实现数组去重" class="headerlink" title="4.1 使用Set实现数组去重"></a>4.1 使用Set实现数组去重</h4><p>在ES6中，因为Set只存储唯一值，所以你可以使用Set删除重复项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 1, 2, 2, 3, 3];</span><br><span class="line">let deduped = [...new Set(arr)] // [1, 2, 3]</span><br></pre></td></tr></table></figure></p><h4 id="4-2-对Set使用数组方法"><a href="#4-2-对Set使用数组方法" class="headerlink" title="4.2 对Set使用数组方法"></a>4.2 对Set使用数组方法</h4><p>使用扩展运算符就可以简单的将Set转换为数组。所以你可以对Set使用Array的所有原生方法。</p><p>比如我们想要对下面的Set进行filter操作，获取大于3的项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let mySet = new Set([1,2, 3, 4, 5]);</span><br><span class="line">var filtered = [...mySet].filter((x) =&gt; x &gt; 3) // [4, 5]</span><br></pre></td></tr></table></figure></p><h3 id="5-数组解构"><a href="#5-数组解构" class="headerlink" title="5. 数组解构"></a>5. 数组解构</h3><p>有时候你会将函数返回的多个值放在一个数组里。我们可以使用数组解构来获取其中每一个值。</p><h4 id="5-1-数值交换"><a href="#5-1-数值交换" class="headerlink" title="5.1 数值交换"></a>5.1 数值交换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let param1 = 1;</span><br><span class="line">let param2 = 2;</span><br><span class="line">//swap and assign param1 &amp; param2 each others values</span><br><span class="line">[param1, param2] = [param2, param1];</span><br><span class="line">console.log(param1) // 2</span><br><span class="line">console.log(param2) // 1</span><br></pre></td></tr></table></figure><h4 id="5-2-接收函数返回的多个结果"><a href="#5-2-接收函数返回的多个结果" class="headerlink" title="5.2 接收函数返回的多个结果"></a>5.2 接收函数返回的多个结果</h4><p>在下面的代码中，我们从/post中获取一个帖子，然后在/comments中获取相关评论。由于我们使用的是async/await，函数把返回值放在一个数组中。而我们使用数组解构后就可以把返回值直接赋给相应的变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function getFullPost()&#123;</span><br><span class="line">  return await Promise.all([</span><br><span class="line">    fetch(&apos;/post&apos;),</span><br><span class="line">    fetch(&apos;/comments&apos;)</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br><span class="line">const [post, comments] = getFullPost();</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;摘要：总结ES6新特性：默认参数、reduce、解构赋值和Set在使用时的一些小技巧。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ES6出来已经有好几年了，同时很多新特性可以被巧妙地运用在项目中。我想要列下其中一些，希望它们对你有用。    &lt;/p&gt;
&lt;p&gt;如果你还知道其他一
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
      <category term="ES6" scheme="http://yoursite.com/categories/js/ES6/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="reduce" scheme="http://yoursite.com/tags/reduce/"/>
    
      <category term="解构" scheme="http://yoursite.com/tags/%E8%A7%A3%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>ES7 异步神器 async-await</title>
    <link href="http://yoursite.com/2018/10/05/async-await/"/>
    <id>http://yoursite.com/2018/10/05/async-await/</id>
    <published>2018-10-05T13:28:10.000Z</published>
    <updated>2018-10-09T11:07:16.125Z</updated>
    
    <content type="html"><![CDATA[<p>关于异步处理，ES5的回调使我们陷入地狱，ES6的Promise使我们脱离魔障，终于、ES7的async-await带我们走向光明。今天就来学习一下 async-await。</p><h3 id="1-async-await和Promise的关系"><a href="#1-async-await和Promise的关系" class="headerlink" title="1. async-await和Promise的关系"></a>1. async-await和Promise的关系</h3><p>经常会看到有了 async-await、promise 还有必要学习吗、async await优于promise的几个特点，接收了这些信息后，就蒙圈了。现在才知道，async-await是promise和generator的语法糖。只是为了让我们书写代码时更加流畅，当然也增强了代码的可读性。简单来说：async-await 是建立在 promise机制之上的，并不能取代其地位。</p><h5 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h5><pre><code>async function basicDemo() {    let result = await Math.random();    console.log(result);}basicDemo();// 0.6484863241051226//Promise {[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: undefined}</code></pre><p>上述代码就是async-await的基本使用形式。有两个陌生的关键字async、await，同时函数执行结果似乎返回了一个promise对象。</p><h3 id="2-async"><a href="#2-async" class="headerlink" title="2. async"></a>2. async</h3><p>async用来表示函数是异步的，定义的函数会返回一个promise对象，可以使用then方法添加回调函数。</p><pre><code>async function demo01() {    return 123;}demo01().then(val =&gt; {    console.log(val);// 123});</code></pre><p><code>若 async 定义的函数有返回值，return 123;相当于Promise.resolve(123),没有声明式的 return则相当于执行了Promise.resolve();</code></p><h3 id="3-await"><a href="#3-await" class="headerlink" title="3. await"></a>3. await</h3><p>await 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。</p><pre><code>function notAsyncFunc() {    await Math.random();}notAsyncFunc();//Uncaught SyntaxError: Unexpected identifier</code></pre><p>await 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，<strong>但是它最主要的意图是用来等待 Promise 对象的状态被 resolved</strong>。如果await的是 promise对象会造成<strong>异步函数<code>停止</code>执行并且<code>等待</code> promise 的解决</strong>，如果等的是正常的表达式则立即执行。</p><pre><code>function sleep(second) {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            resolve(&apos; enough sleep~&apos;);        }, second);    })}function normalFunc() {    console.log(&apos;normalFunc&apos;);}async function awaitDemo() {    await normalFunc();    console.log(&apos;something, ~~&apos;);    let result = await sleep(2000);    console.log(result);// 两秒之后会被打印出来}awaitDemo();// normalFunc// VM4036:13 something, ~~// VM4036:15  enough sleep~</code></pre><p>希望通过上面的 demo，大家可以理解我上面的话。</p><h3 id="4-实例"><a href="#4-实例" class="headerlink" title="4. 实例"></a>4. 实例</h3><p>举例说明啊，你有三个请求需要发生，第三个请求是依赖于第二个请求的解构第二个请求依赖于第一个请求的结果。若用 ES5实现会有3层的回调，若用Promise 实现至少需要3个then。一个是代码横向发展，另一个是纵向发展。今天指给出 async-await 的实现哈~</p><pre><code>//我们仍然使用 setTimeout 来模拟异步请求function sleep(second, param) {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            resolve(param);        }, second);    })}async function test() {    let result1 = await sleep(2000, &apos;req01&apos;);    let result2 = await sleep(1000, &apos;req02&apos; + result1);    let result3 = await sleep(500, &apos;req03&apos; + result2);    console.log(`        ${result3}        ${result2}        ${result1}    `);}test();//req03req02req01//req02req01//req01</code></pre><h3 id="5-错误处理"><a href="#5-错误处理" class="headerlink" title="5. 错误处理"></a>5. 错误处理</h3><p>上述的代码好像给的都是resolve的情况，那么reject的时候我们该如何处理呢？</p><pre><code>function sleep(second) {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            reject(&apos;want to sleep~&apos;);        }, second);    })}async function errorDemo() {    let result = await sleep(1000);    console.log(result);}errorDemo();// VM706:11 Uncaught (in promise) want to sleep~// 为了处理Promise.reject 的情况我们应该将代码块用 try catch 包裹一下async function errorDemoSuper() {    try {        let result = await sleep(1000);        console.log(result);    } catch (err) {        console.log(err);    }}errorDemoSuper();// want to sleep~// 有了 try catch 之后我们就能够拿到 Promise.reject 回来的数据了。</code></pre><h3 id="6-小心你的并行处理"><a href="#6-小心你的并行处理" class="headerlink" title="6. 小心你的并行处理!!!"></a>6. 小心你的并行处理!!!</h3><p>我这里为啥加了三个感叹号呢~，因为对于初学者来说一不小心就将 ajax 的并发请求发成了阻塞式同步的操作了，我就真真切切的在工作中写了这样的代码。<strong>await 若等待的是 promise 就会停止下来</strong>。业务是这样的，我有三个异步请求需要发送，相互没有关联，只是需要当请求都结束后将界面的 loading 清除掉即可。<br>刚学完 async await 开心啊，到处乱用~</p><pre><code>function sleep(second) {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            resolve(&apos;request done! &apos; + Math.random());        }, second);    })}async function bugDemo() {    await sleep(1000);    await sleep(1000);    await sleep(1000);    console.log(&apos;clear the loading~&apos;);}bugDemo();</code></pre><p>loading 确实是等待请求都结束完才清除的。但是你认真的观察下浏览器的 timeline 请求是一个结束后再发另一个的（若观察效果请发真实的 ajax 请求）<br>那么，正常的处理是怎样的呢？</p><pre><code>async function correctDemo() {    let p1 = sleep(1000);    let p2 = sleep(1000);    let p3 = sleep(1000);    await Promise.all([p1, p2, p3]);    console.log(&apos;clear the loading~&apos;);}correctDemo();// clear the loading~</code></pre><p><strong><code>恩， 完美。看吧~ async-await 并不能取代 promise.</code></strong></p><h3 id="7-await-in-for-循环"><a href="#7-await-in-for-循环" class="headerlink" title="7.await in for 循环"></a>7.await in for 循环</h3><p>最后一点了，await必须在async函数的上下文中的。</p><pre><code>// 正常 for 循环async function forDemo() {    let arr = [1, 2, 3, 4, 5];    for (let i = 0; i &lt; arr.length; i ++) {        await arr[i];    }}forDemo();//正常输出// 因为想要炫技把 for循环写成下面这样async function forBugDemo() {    let arr = [1, 2, 3, 4, 5];    arr.forEach(item =&gt; {        await item;    });}forBugDemo();// Uncaught SyntaxError: Unexpected identifier</code></pre><h3 id="8-refs"><a href="#8-refs" class="headerlink" title="8. refs"></a>8. refs</h3><p>不知道，我的意思有没有传递给大家。下面推荐几篇优秀的文章。</p><p><a href="http://www.ruanyifeng.com/blog/2015/05/async.html" target="_blank" rel="noopener">async 函数的含义和用法</a><br><a href="https://medium.com/@peterchang_82818/javascript-es7-async-await-%E6%95%99%E5%AD%B8-703473854f29-tutorial-example-703473854f29" target="_blank" rel="noopener">ES7 Async Await 聖經</a><br><a href="https://ponyfoo.com/articles/understanding-javascript-async-await" target="_blank" rel="noopener">Understanding JavaScript’s async await</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于异步处理，ES5的回调使我们陷入地狱，ES6的Promise使我们脱离魔障，终于、ES7的async-await带我们走向光明。今天就来学习一下 async-await。&lt;/p&gt;
&lt;h3 id=&quot;1-async-await和Promise的关系&quot;&gt;&lt;a href=&quot;#1
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
      <category term="异步" scheme="http://yoursite.com/categories/js/%E5%BC%82%E6%AD%A5/"/>
    
    
      <category term="异步-等待" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5-%E7%AD%89%E5%BE%85/"/>
    
      <category term="async-await" scheme="http://yoursite.com/tags/async-await/"/>
    
  </entry>
  
  <entry>
    <title>ES6 Promise 用法讲解</title>
    <link href="http://yoursite.com/2018/10/04/promise/"/>
    <id>http://yoursite.com/2018/10/04/promise/</id>
    <published>2018-10-04T12:48:55.000Z</published>
    <updated>2018-10-04T13:06:40.614Z</updated>
    
    <content type="html"><![CDATA[<p>Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。</p><p>那就new一个</p><pre><code>var p = new Promise(function(resolve, reject){    //做一些异步操作    setTimeout(function(){    console.log(&apos;执行完成&apos;);    resolve(&apos;随便什么数据&apos;);    }, 2000);});</code></pre><p>Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected。不过在我们开始阶段可以先这么理解，后面再细究概念。</p><p>在上面的代码中，我们执行了一个异步操作，也就是setTimeout，2秒后，输出“执行完成”，并且调用resolve方法。</p><p>运行代码，会在2秒后输出“执行完成”。注意！我只是new了一个对象，并没有调用它，我们传进去的函数就已经执行了，这是需要注意的一个细节。所以我们用Promise的时候一般是包在一个函数中，在需要的时候去运行这个函数，如：</p><pre><code>function runAsync(){    var p = new Promise(function(resolve, reject){        //做一些异步操作        setTimeout(function(){            console.log(&apos;执行完成&apos;);            resolve(&apos;随便什么数据&apos;);        }, 2000);    });    return p;            }runAsync()</code></pre><p>这时候你应该有两个疑问：1.包装这么一个函数有毛线用？2.resolve(‘随便什么数据’);这是干毛的？</p><p>我们继续来讲。在我们包装好的函数最后，会return出Promise对象，也就是说，执行这个函数我们得到了一个Promise对象。还记得Promise对象上有then、catch方法吧？这就是强大之处了，看下面的代码：</p><pre><code>runAsync().then(function(data){    console.log(data);    //后面可以用传过来的数据做些其他操作    //......});</code></pre><p>在runAsync()的返回上直接调用then方法，then接收一个参数，是函数，并且会拿到我们在runAsync中调用resolve时传的的参数。运行这段代码，会在2秒后输出“执行完成”，紧接着输出“随便什么数据”。</p><p>这时候你应该有所领悟了，原来then里面的函数就跟我们平时的回调函数一个意思，能够在runAsync这个异步任务执行完成之后被执行。这就是Promise的作用了，简单来讲，就是能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。</p><p>你可能会不屑一顾，那么牛逼轰轰的Promise就这点能耐？我把回调函数封装一下，给runAsync传进去不也一样吗，就像这样：</p><pre><code>function runAsync(callback){    setTimeout(function(){        console.log(&apos;执行完成&apos;);        callback(&apos;随便什么数据&apos;);    }, 2000);}runAsync(function(data){    console.log(data);});</code></pre><p>效果也是一样的，还费劲用Promise干嘛。那么问题来了，有多层回调该怎么办？如果callback也是一个异步操作，而且执行完后也需要有相应的回调函数，该怎么办呢？总不能再定义一个callback2，然后给callback传进去吧。而Promise的优势在于，可以在then方法中继续写Promise对象并返回，然后继续调用then来进行回调操作。</p><h3 id="1-链式操作的用法"><a href="#1-链式操作的用法" class="headerlink" title="1. 链式操作的用法"></a>1. 链式操作的用法</h3><p>所以，从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。所以使用Promise的正确场景是这样的：</p><pre><code>runAsync1().then(function(data){    console.log(data);    return runAsync2();}).then(function(data){    console.log(data);    return runAsync3();}).then(function(data){    console.log(data);});</code></pre><p>这样能够按顺序，每隔两秒输出每个异步回调中的内容，在runAsync2中传给resolve的数据，能在接下来的then方法中拿到。运行结果如下：</p><p><img src="https://i.imgur.com/UzPYUGV.png" alt=""></p><p>猜猜runAsync1、runAsync2、runAsync3这三个函数都是如何定义的？没错，就是下面这样</p><pre><code>function runAsync1(){    var p = new Promise(function(resolve, reject){        //做一些异步操作        setTimeout(function(){            console.log(&apos;异步任务1执行完成&apos;);            resolve(&apos;随便什么数据1&apos;);        }, 1000);    });    return p;            }function runAsync2(){    var p = new Promise(function(resolve, reject){        //做一些异步操作        setTimeout(function(){            console.log(&apos;异步任务2执行完成&apos;);            resolve(&apos;随便什么数据2&apos;);        }, 2000);    });    return p;            }function runAsync3(){    var p = new Promise(function(resolve, reject){        //做一些异步操作        setTimeout(function(){            console.log(&apos;异步任务3执行完成&apos;);            resolve(&apos;随便什么数据3&apos;);        }, 2000);    });    return p;            }</code></pre><p>在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了，比如我们把上面的代码修改成这样：</p><pre><code>runAsync1().then(function(data){    console.log(data);    return runAsync2();}).then(function(data){    console.log(data);    return &apos;直接返回数据&apos;;  //这里直接返回数据}).then(function(data){    console.log(data);});</code></pre><p>那么输出就变成了这样：</p><p><img src="https://i.imgur.com/eKDGP7y.png" alt=""></p><h3 id="2-reject的用法"><a href="#2-reject的用法" class="headerlink" title="2. reject的用法"></a>2. reject的用法</h3><p>到这里，你应该对“Promise是什么玩意”有了最基本的了解。那么我们接着来看看ES6的Promise还有哪些功能。我们光用了resolve，还没用reject呢，它是做什么的呢？事实上，我们前面的例子都是只有“执行成功”的回调，还没有“失败”的情况，reject的作用就是把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。看下面的代码。</p><pre><code>function getNumber(){    var p = new Promise(function(resolve, reject){        //做一些异步操作        setTimeout(function(){            var num = Math.ceil(Math.random()*10); //生成1-10的随机数            if(num&lt;=5){                resolve(num);            }            else{                reject(&apos;数字太大了&apos;);            }        }, 2000);    });    return p;            }getNumber().then(    function(data){        console.log(&apos;resolved&apos;);        console.log(data);    },     function(reason, data){        console.log(&apos;rejected&apos;);        console.log(reason);    });</code></pre><p>getNumber函数用来异步获取一个数字，2秒后执行完成，如果数字小于等于5，我们认为是“成功”了，调用resolve修改Promise的状态。否则我们认为是“失败”了，调用reject并传递一个参数，作为失败的原因。</p><p>运行getNumber并且在then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果：</p><p><img src="https://i.imgur.com/I53EybP.png" alt="">或者s<img src="https://i.imgur.com/S2jZdKw.png" alt=""></p><h3 id="3-catch的用法"><a href="#3-catch的用法" class="headerlink" title="3. catch的用法"></a>3. catch的用法</h3><p>我们知道Promise对象除了then方法，还有一个catch方法，它是做什么用的呢？其实它和then的第二个参数一样，用来指定reject的回调，用法是这样：</p><pre><code>getNumber().then(function(data){    console.log(&apos;resolved&apos;);    console.log(data);}).catch(function(reason){    console.log(&apos;rejected&apos;);    console.log(reason);});</code></pre><p>效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。请看下面的代码：</p><pre><code>getNumber().then(function(data){    console.log(&apos;resolved&apos;);    console.log(data);    console.log(somedata); //此处的somedata未定义}).catch(function(reason){    console.log(&apos;rejected&apos;);    console.log(reason);});</code></pre><p>在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果：</p><p><img src="https://i.imgur.com/WsZuzIl.png" alt=""></p><p>也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错了，这与我们的try/catch语句有相同的功能。</p><h3 id="4-all的用法"><a href="#4-all的用法" class="headerlink" title="4. all的用法"></a>4. all的用法</h3><p>Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。我们仍旧使用上面定义好的runAsync1、runAsync2、runAsync3这三个函数，看下面的例子：</p><pre><code>Promise.all([runAsync1(), runAsync2(), runAsync3()]).then(function(results){    console.log(results);});</code></pre><p>用Promise.all来执行，all接收一个数组参数，里面的值最终都算返回Promise对象。这样，三个异步操作的并行执行的，等到它们都执行完后才会进到then里面。那么，三个异步操作返回的数据哪里去了呢？都在then里面呢，all会把所有异步操作的结果放进一个数组中传给then，就是上面的results。所以上面代码的输出结果就是：</p><p><img src="https://i.imgur.com/vBMvhAW.png" alt=""></p><p>有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。</p><h3 id="5-race的用法"><a href="#5-race的用法" class="headerlink" title="5. race的用法"></a>5. race的用法</h3><p>all方法的效果实际上是「谁跑的慢，以谁为准执行回调」，那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」，这就是race方法，这个词本来就是赛跑的意思。race的用法与all一样，我们把上面runAsync1的延时改为1秒来看一下：</p><pre><code>Promise.race([runAsync1(), runAsync2(), runAsync3()]).then(function(results){    console.log(results);});</code></pre><p>这三个异步操作同样是并行执行的。结果你应该可以猜到，1秒后runAsync1已经执行完了，此时then里面的就执行了。结果是这样的：</p><p><img src="https://i.imgur.com/ggNitgj.png" alt=""></p><p>你猜对了吗？不完全，是吧。在then里面的回调开始执行时，runAsync2()和runAsync3()并没有停止，仍旧再执行。于是再过1秒后，输出了他们结束的标志。</p><p>这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下：</p><pre><code>//请求某个图片资源function requestImg(){    var p = new Promise(function(resolve, reject){        var img = new Image();        img.onload = function(){            resolve(img);        }        img.src = &apos;xxxxxx&apos;;    });    return p;}//延时函数，用于给请求计时function timeout(){    var p = new Promise(function(resolve, reject){        setTimeout(function(){            reject(&apos;图片请求超时&apos;);        }, 5000);    });    return p;}Promise.race([requestImg(), timeout()]).then(function(results){    console.log(results);}).catch(function(reason){    console.log(reason);});</code></pre><p>requestImg函数会异步请求一张图片，我把地址写为”xxxxxx”，所以肯定是无法成功请求到的。timeout函数是一个延时5秒的异步操作。我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入then方法，执行正常的流程。如果5秒钟图片还未成功返回，那么timeout就跑赢了，则进入catch，报出“图片请求超时”的信息。运行结果如下：</p><p><img src="https://i.imgur.com/vE5yIwn.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。&lt;/p&gt;
&lt;p&gt;那就new一个&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var p = new Promise(function(resolv
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
      <category term="异步" scheme="http://yoursite.com/categories/js/%E5%BC%82%E6%AD%A5/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="Promise" scheme="http://yoursite.com/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>js 遍历方法汇总</title>
    <link href="http://yoursite.com/2018/08/29/js%E9%81%8D%E5%8E%86%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2018/08/29/js遍历汇总/</id>
    <published>2018-08-29T12:47:55.000Z</published>
    <updated>2018-08-29T12:47:15.638Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-for-循环"><a href="#1-for-循环" class="headerlink" title="1. for 循环"></a>1. for 循环</h3><p>使用临时变量，将长度缓存起来，避免重复获取数组长度，当数组长度较大时，优化效果才会比较明显。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0, len = arr.length; i &lt; len; i++)&#123;</span><br><span class="line">//do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-es3-forEach-循环"><a href="#2-es3-forEach-循环" class="headerlink" title="2. es3 forEach 循环"></a>2. es3 forEach 循环</h3><p>遍历数组中的每一项，没有返回值，对原数组没有影响。</p><p><code>注意: forEach() 1.对于空数组是不会执行回调函数的； 2.且无法在所有元素都传递给调用的函数之前终止遍历。</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//1 没有返回值</span><br><span class="line">arr.forEach((item,index,array) =&gt; &#123;</span><br><span class="line">    //执行代码</span><br><span class="line">&#125;,this.value)</span><br><span class="line">//参数：item数组中的当前项, index当前项的索引, array原始数组；</span><br><span class="line">//this.value: 可选。传递给函数的值一般用 &quot;this&quot; 值。如果这个参数为空， &quot;undefined&quot; 会传递给 &quot;this&quot; 值</span><br><span class="line">//数组中有几项，那么传递进去的匿名回调函数就需要执行几次；</span><br></pre></td></tr></table></figure><h3 id="3-map-循环"><a href="#3-map-循环" class="headerlink" title="3. map 循环"></a>3. map 循环</h3><p>有返回值，可以 return 出来</p><p><strong>与 forEach 不同点：</strong></p><ol><li><p>forEach() 方法对数组的每个元素执行一次提供的函数。总是返回 undefined；</p></li><li><p>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。返回值是一个新的数组，并不影响原来的数组；</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">arr.map(function(value,index,array)&#123;</span><br><span class="line"></span><br><span class="line">　　//do something</span><br><span class="line"></span><br><span class="line">　　return XXX</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var ary = [12,23,24,42,1];</span><br><span class="line">var res = ary.map(function (item,index,ary ) &#123;</span><br><span class="line">    return item*10;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(res);//--&gt;[120,230,240,420,10];  原数组拷贝了一份，并进行了修改</span><br><span class="line">console.log(ary);//--&gt;[12,23,24,42,1]；  原数组并未发生变化</span><br></pre></td></tr></table></figure><h3 id="4-for…of-遍历"><a href="#4-for…of-遍历" class="headerlink" title="4. for…of 遍历"></a>4. for…of 遍历</h3><p>可以正确响应 break、continue 和 return 语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var value of myArray) &#123;</span><br><span class="line">console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>与 for…in 比较:</strong></p><p>用 for in 不仅可以对数组,也可以对 enumerable 对象操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var A = &#123;a:1,b:2,c:3,d:&quot;hello world&quot;&#125;;</span><br><span class="line">for(let k in A) &#123;</span><br><span class="line">    console.log(k,A[k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>总结来说:1.for in 总是得到对像的key或数组,字符串的下标，而 for of 和 forEach 一样，是直接得到值</code></p><p><code>2.for of 不能用于对象</code></p><h3 id="5-filter-遍历"><a href="#5-filter-遍历" class="headerlink" title="5. filter 遍历"></a>5. filter 遍历</h3><p>不会改变原始数组,返回新数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var arr = [</span><br><span class="line">  &#123; id: 1, text: &apos;aa&apos;, done: true &#125;,</span><br><span class="line">  &#123; id: 2, text: &apos;bb&apos;, done: false &#125;</span><br><span class="line">]</span><br><span class="line">console.log(arr.filter(item =&gt; item.done))</span><br><span class="line">//转为ES5</span><br><span class="line"></span><br><span class="line">arr.filter(function (item) &#123;</span><br><span class="line">  return item.done;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var arr = [73,84,56, 22,100]</span><br><span class="line">var newArr = arr.filter(item =&gt; item&gt;80)   //得到新数组 [84, 100]</span><br><span class="line">console.log(newArr,arr)</span><br></pre></td></tr></table></figure><h3 id="6-every-遍历"><a href="#6-every-遍历" class="headerlink" title="6. every 遍历"></a>6. every 遍历</h3><p>every()是对数组中的每一项运行给定函数，如果该函数对每一项返回 true,则返回 true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [ 1, 2, 3, 4, 5, 6 ];</span><br><span class="line">console.log( arr.every( function( item, index, array )&#123;</span><br><span class="line">        return item &gt; 3;</span><br><span class="line">    &#125;));</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h3 id="7-some-遍历"><a href="#7-some-遍历" class="headerlink" title="7. some 遍历"></a>7. some 遍历</h3><p>some()是对数组中每一项运行指定函数，如果该函数对任一项返回 true，则返回 true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = [ 1, 2, 3, 4, 5, 6 ];</span><br><span class="line"></span><br><span class="line">    console.log( arr.some( function( item, index, array )&#123;</span><br><span class="line">        return item &gt; 3;</span><br><span class="line">    &#125;));</span><br><span class="line">true</span><br></pre></td></tr></table></figure><h3 id="8-reduce"><a href="#8-reduce" class="headerlink" title="8. reduce"></a>8. reduce</h3><p>reduce() 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var total = [0,1,2,3,4].reduce((a, b)=&gt;a + b); //10</span><br></pre></td></tr></table></figure><p>reduce 接受一个函数，函数有四个参数，分别是：上一次的值，当前值，当前值的索引，数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, index, array)&#123;</span><br><span class="line"> return previousValue + currentValue;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>reduce 还有第二个参数，我们可以把这个参数作为第一次调用 callback 时的第一个参数，上面这个例子因为没有第二个参数，所以直接从数组的第二项开始，如果我们给了第二个参数为 5，那么结果就是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, index, array)&#123;</span><br><span class="line"> return previousValue + currentValue;</span><br><span class="line">&#125;,5);</span><br></pre></td></tr></table></figure><p>第一次调用的 previousValue 的值就用传入的第二个参数代替，</p><h3 id="9-reduceRight"><a href="#9-reduceRight" class="headerlink" title="9. reduceRight"></a>9. reduceRight</h3><p>reduceRight()方法的功能和 reduce()功能是一样的，不同的是 reduceRight()从数组的末尾向前将数组中的数组项做累加。</p><p>reduceRight()首次调用回调函数 callbackfn 时，prevValue 和 curValue 可以是两个值之一。如果调用 reduceRight() 时提供了 initialValue 参数，则 prevValue 等于 initialValue，curValue 等于数组中的最后一个值。如果没有提供 initialValue 参数，则 prevValue 等于数组最后一个值， curValue 等于数组中倒数第二个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [0,1,2,3,4];</span><br><span class="line"></span><br><span class="line">arr.reduceRight(function (preValue,curValue,index,array) &#123;</span><br><span class="line">    return preValue + curValue;</span><br><span class="line">&#125;); // 10</span><br></pre></td></tr></table></figure><p>回调将会被调用四次，每次调用的参数及返回值如下：</p><p>如果提供一个初始值 initialValue 为 5:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [0,1,2,3,4];</span><br><span class="line"></span><br><span class="line">arr.reduceRight(function (preValue,curValue,index,array) &#123;</span><br><span class="line">    return preValue + curValue;</span><br><span class="line">&#125;, 5); // 15</span><br></pre></td></tr></table></figure><p>回调将会被调用五次，每次调用的参数及返回的值如下：</p><p>同样的，可以对一个数组求和，也可以使用 reduceRight()方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4,5,6];</span><br><span class="line"></span><br><span class="line">console.time(&quot;ruduceRight&quot;);</span><br><span class="line">Array.prototype.ruduceRightSum = function ()&#123;</span><br><span class="line">    for (var i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">        return  this.reduceRight (function (preValue, curValue) &#123;</span><br><span class="line">            return preValue + curValue;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr.ruduceRightSum();</span><br><span class="line">console.log(&apos;最终的值：&apos; + arr.ruduceSum()); // 21</span><br><span class="line">console.timeEnd(&quot;ruduceRight&quot;); // 5.725ms</span><br></pre></td></tr></table></figure><h3 id="10-find"><a href="#10-find" class="headerlink" title="10. find"></a>10. find</h3><p>find()方法返回数组中符合测试函数条件的<strong><code>第一个</code></strong>元素。否则返回 undefined</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var stu = [</span><br><span class="line">    &#123;</span><br><span class="line">        name: &apos;张三&apos;,</span><br><span class="line">        gender: &apos;男&apos;,</span><br><span class="line">        age: 20</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &apos;王小毛&apos;,</span><br><span class="line">        gender: &apos;男&apos;,</span><br><span class="line">        age: 20</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: &apos;李四&apos;,</span><br><span class="line">        gender: &apos;男&apos;,</span><br><span class="line">        age: 20</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">function getStu(element)&#123;</span><br><span class="line">   return element.name == &apos;李四&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stu.find(getStu)</span><br><span class="line">//返回结果为</span><br><span class="line">//&#123;name: &quot;李四&quot;, gender: &quot;男&quot;, age: 20&#125;</span><br></pre></td></tr></table></figure><p>ES6 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stu.find((element) =&gt; (element.name == &apos;李四&apos;))</span><br></pre></td></tr></table></figure><h3 id="11-findIndex"><a href="#11-findIndex" class="headerlink" title="11. findIndex"></a>11. findIndex</h3><p>对于数组中的每个元素，findIndex 方法都会调用一次回调函数（采用升序索引顺序），直到有元素返回 true。只要有一个元素返回 true，findIndex 立即返回该返回 true 的元素的索引值。如果数组中没有任何元素返回 true，则 findIndex 返回 -1。</p><p>findIndex 不会改变数组对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3].findIndex(function(x) &#123; x == 2; &#125;);</span><br><span class="line">// Returns an index value of 1.</span><br><span class="line"></span><br><span class="line">[1,2,3].findIndex(x =&gt; x == 4);</span><br><span class="line">// Returns an index value of -1.</span><br></pre></td></tr></table></figure><h3 id="12-keys，values，entries"><a href="#12-keys，values，entries" class="headerlink" title="12. keys，values，entries"></a>12. keys，values，entries</h3><p><code>ES6</code>提供一个新的方法 —— keys()，<code>ES8</code>又新增了两个方法 entries()和 values() —— 用于遍历数组。它们都返回一个遍历器对象，可以用 for…of 循环进行遍历，唯一的区别是 keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123;</span><br><span class="line">console.log(index);</span><br><span class="line">&#125;</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line">for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123;</span><br><span class="line">console.log(elem);</span><br><span class="line">&#125;</span><br><span class="line">// &apos;a&apos;</span><br><span class="line">// &apos;b&apos;</span><br><span class="line">for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123;</span><br><span class="line">console.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line">// 0 &quot;a&quot;</span><br><span class="line">// 1 &quot;b&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-for-循环&quot;&gt;&lt;a href=&quot;#1-for-循环&quot; class=&quot;headerlink&quot; title=&quot;1. for 循环&quot;&gt;&lt;/a&gt;1. for 循环&lt;/h3&gt;&lt;p&gt;使用临时变量，将长度缓存起来，避免重复获取数组长度，当数组长度较大时，优化效果才会比较明
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
      <category term="js遍历" scheme="http://yoursite.com/categories/js/js%E9%81%8D%E5%8E%86/"/>
    
    
      <category term="for of" scheme="http://yoursite.com/tags/for-of/"/>
    
      <category term="遍历数组" scheme="http://yoursite.com/tags/%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown语法总结</title>
    <link href="http://yoursite.com/2018/08/28/MarkDown%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/08/28/MarkDown语法总结/</id>
    <published>2018-08-28T12:19:15.000Z</published>
    <updated>2018-08-29T12:41:52.821Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h3><h4 id="a-一级标题"><a href="#a-一级标题" class="headerlink" title="a. 一级标题"></a>a. 一级标题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方式一： #1.一级标题</span><br><span class="line">方式二： 一级标题+分割线</span><br><span class="line">   =============</span><br></pre></td></tr></table></figure><h4 id="b-二级标题加分割线"><a href="#b-二级标题加分割线" class="headerlink" title="b. 二级标题加分割线"></a>b. 二级标题加分割线</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二级标题</span><br><span class="line">-------</span><br></pre></td></tr></table></figure><h4 id="c-1-6-标题："><a href="#c-1-6-标题：" class="headerlink" title="c. 1-6 标题："></a>c. 1-6 标题：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#1级标题</span><br><span class="line">##</span><br><span class="line">...</span><br><span class="line">### ### 6级标题</span><br></pre></td></tr></table></figure><h3 id="3-分割线"><a href="#3-分割线" class="headerlink" title="3. 分割线"></a>3. 分割线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*****</span><br><span class="line">-----</span><br></pre></td></tr></table></figure><h3 id="4-首行缩进"><a href="#4-首行缩进" class="headerlink" title="4. 首行缩进"></a>4. 首行缩进</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中文： &amp;emsp;</span><br><span class="line">英文： &amp;nbsp;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;段落的前后要有空行，所谓的空行<br> 是指没有文字内容。若想在段内强制换行的方式是使用两个以上空格加上回车（引用中换行省略回车）。</p><h3 id="5-区块引用"><a href="#5-区块引用" class="headerlink" title="5. 区块引用"></a>5. 区块引用</h3><p>在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 区块引用</span><br><span class="line">&gt;&gt; 嵌套引用</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>区块引用</p><blockquote><p>嵌套引用</p></blockquote></blockquote><h3 id="6-代码区块"><a href="#6-代码区块" class="headerlink" title="6. 代码区块"></a>6. 代码区块</h3><p>代码区块的建立是在每行加上 4 个空格或者一个制表符（如同写代码一样）。<br>如普通段落：</p><p>首尾加制表符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Hello, Markdown.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>每行加四个空格 &lt; <em>首尾空需空行隔开</em> &gt;：</strong></p><pre><code>void main(){    printf(&quot;Hello, Markdown.&quot;);}&lt;div class=&quot;footer&quot;&gt;    © 2004 Foo Corporation&lt;/div&gt;</code></pre><h3 id="7-强调"><a href="#7-强调" class="headerlink" title="7. 强调"></a>7. 强调</h3><p>在强调内容两侧分别加上*或者_，如：</p><pre><code>*斜体*，_斜体_**粗体**，__粗体__</code></pre><p>效果：</p><p>_斜体_，_斜体_<br><strong>粗体</strong>，<strong>粗体</strong></p><h3 id="8-列表"><a href="#8-列表" class="headerlink" title="8. 列表"></a>8. 列表</h3><p>使用·、+、或-标记<strong>无序列表</strong>，如：</p><pre><code>-（+*） 第一项 -（+*） 第二项 - （+*）第三项</code></pre><p><em>`注意：标记后面最少有一个</em>空格<em>或</em>制表符<em>。若不在引用区块中，必须和前方段落之间存在空行。`</em></p><p>效果：</p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><p><strong>有序列表</strong>的标记方式是将上述的符号换成数字,并辅以.，如：</p><pre><code>1. 第一项2. 第二项3. 第三项</code></pre><p>效果：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="9-链接"><a href="#9-链接" class="headerlink" title="9.链接"></a>9.链接</h3><p>链接可以由两种形式生成：行内式和参考式。<br>行内式：</p><pre><code>[younghz的Markdown库](https://github.com/younghz/Markdown &quot;Markdown&quot;)。</code></pre><p>效果：</p><p><a href="https://github.com/younghz/Markdown" title="Markdown" target="_blank" rel="noopener">younghz 的 Markdown 库</a>。</p><p>参考式：</p><pre><code>[younghz的Markdown库1][1][younghz的Markdown库2][2][1]:https://github.com/younghz/Markdown &quot;Markdown&quot;[2]:https://github.com/younghz/Markdown &quot;Markdown&quot;</code></pre><p>效果：</p><p>[younghz 的 Markdown 库 1][1]<br>[younghz 的 Markdown 库 2][2]<br>[1]:<a href="https://github.com/younghz/Markdown" target="_blank" rel="noopener">https://github.com/younghz/Markdown</a> “Markdown”<br>[2]:<a href="https://github.com/younghz/Markdown" target="_blank" rel="noopener">https://github.com/younghz/Markdown</a> “Markdown”</p><blockquote><p>注意： 上述的[1]:https:://github.com/younghz/Markdown “Markdown”不出现在区块中</p></blockquote><h3 id="10-图片"><a href="#10-图片" class="headerlink" title="10. 图片"></a>10. 图片</h3><p>添加图片的形式和链接相似，只需在链接的基础上前方加一个！。</p><pre><code>![百度一下](https://www.baidu.com/img/bd_logo1.png &quot;百度一下&quot;)</code></pre><p><a href="http://www.baidu.com" target="_blank" rel="noopener"><img src="../../../../images/searchicon.png" alt="百度一下" title="百度一下"></a></p><h3 id="11-反斜杠"><a href="#11-反斜杠" class="headerlink" title="11. 反斜杠\"></a>11. 反斜杠\</h3><p>相当于反转义作用。使符号成为普通符号。</p><pre><code>\``\&amp;nbsp;</code></pre><p>效果：</p><p>``<br>\&nbsp;</p><h3 id="12-符号"><a href="#12-符号" class="headerlink" title="12. 符号 `"></a>12. 符号 `</h3><p>起到标记作用。如：</p><pre><code>`ctrl+a`</code></pre><p>效果：</p><p><code>ctrl+a</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-标题&quot;&gt;&lt;a href=&quot;#1-标题&quot; class=&quot;headerlink&quot; title=&quot;1. 标题&quot;&gt;&lt;/a&gt;1. 标题&lt;/h3&gt;&lt;h4 id=&quot;a-一级标题&quot;&gt;&lt;a href=&quot;#a-一级标题&quot; class=&quot;headerlink&quot; title=&quot;a. 
      
    
    </summary>
    
      <category term="工具类" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
      <category term="MarkDown语法" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/MarkDown%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="MarkDown基本语法总结" scheme="http://yoursite.com/tags/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>利用Object.keys遍历(forEach/map)对象数组，合并</title>
    <link href="http://yoursite.com/2018/08/20/objectKeys/"/>
    <id>http://yoursite.com/2018/08/20/objectKeys/</id>
    <published>2018-08-20T12:30:15.000Z</published>
    <updated>2018-08-19T09:48:36.605Z</updated>
    
    <content type="html"><![CDATA[<p>js 中几种遍历对象的方法，包括 for..of、for..in、Object.keys、Object.getOwnProperty,它们在使用场景方面各有不同。</p><p>js 对象的属性中可直接用、可访问到的属性分为数据属性和访问器属性。</p><h4 id="数据属性（实际存储属性值的属性）的四大特性："><a href="#数据属性（实际存储属性值的属性）的四大特性：" class="headerlink" title="数据属性（实际存储属性值的属性）的四大特性："></a>数据属性（实际存储属性值的属性）的四大特性：</h4><pre><code>{     value: 属性值,    writable: true/false,  //控制是否可修改    enumerable: true/false, //控制是否可被for in遍历    configurable: true/false, //1. 控制是否可删除 2. 控制是否可修改前两个特性  3.一旦改为false不可逆}</code></pre><h4 id="访问器属性（不实际存储数据，专门提供对其它数据-变量的保护）的四大特性："><a href="#访问器属性（不实际存储数据，专门提供对其它数据-变量的保护）的四大特性：" class="headerlink" title="访问器属性（不实际存储数据，专门提供对其它数据/变量的保护）的四大特性："></a>访问器属性（不实际存储数据，专门提供对其它数据/变量的保护）的四大特性：</h4><pre><code>{    get:function(){return this.隐藏属性;},    set:function(val){    //如果val符合条件        this.隐藏属性=val    //否则        报错},enumerable, configurable}</code></pre><h3 id="1-for-in"><a href="#1-for-in" class="headerlink" title="1. for..in"></a>1. for..in</h3><hr><p>返回的是所有能够通过对象访问的、可枚举的属性，既包括存在于实例中的属性，也包括存在于原型中的实例,不能保证属性按对象原来的顺序输出。（可枚举-自身-原型）</p><pre><code>var obj = {a:1, b:2, c:3};for (var prop in obj) {  console.log(&quot;obj.&quot; + prop + &quot; = &quot; + obj[prop]);}// Output:// &quot;obj.a = 1&quot;// &quot;obj.b = 2&quot;// &quot;obj.c = 3&quot;</code></pre><h3 id="2-Object-keys"><a href="#2-Object-keys" class="headerlink" title="2. Object.keys"></a>2. Object.keys</h3><hr><p>用于获取对象自身所有的可枚举的属性值，但不包括原型中的属性，然后返回一个由属性名组成的数组。注意它同 for..in 一样不能保证属性按对象原来的顺序输出。（可枚举-自身）</p><pre><code>// 数组var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];console.log(Object.keys(arr)); // console: [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;]// 类数组对象var obj = { 0: &apos;a&apos;, 1: &apos;b&apos;, 2: &apos;c&apos; };console.log(Object.keys(obj)); // console: [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;]// 类数组对象-随机下标var anObj = { 100: &apos;a&apos;, 2: &apos;b&apos;, 7: &apos;c&apos; };console.log(Object.keys(anObj)); // console: [&apos;2&apos;, &apos;7&apos;, &apos;100&apos;]// 不可枚举属性getFoovar myObj = Object.create({}, {  getFoo: {value: function () { return this.foo; }  }});myObj.foo = 1;console.log(Object.keys(myObj)); // console: [&apos;foo&apos;]</code></pre><h3 id="3-Object-getOwnProperty"><a href="#3-Object-getOwnProperty" class="headerlink" title="3. Object.getOwnProperty"></a>3. Object.getOwnProperty</h3><hr><p>如果你想获取一个对象的所有属性，甚至包括不可枚举的，则可用该方法。其返回对象的所有自身属性的属性名组成的数组，但不会获取原型链上的属性。（可枚举&amp;不可枚举-自身）</p><pre><code>//获取不可枚举属性var my_obj = Object.create({}, {  getFoo: {value: function() { return this.foo; },enumerable: false  }});my_obj.foo = 1;console.log(Object.getOwnPropertyNames(my_obj).sort()); // [&quot;foo&quot;, &quot;getFoo&quot;]</code></pre><p>下面的例子演示了该方法不会获取到原型链上的属性：</p><pre><code>function ParentClass() {}ParentClass.prototype.inheritedMethod = function() {};function ChildClass() {  this.prop = 5;  this.method = function() {};}ChildClass.prototype = new ParentClass;ChildClass.prototype.prototypeMethod = function() {};console.log(  Object.getOwnPropertyNames(new ChildClass()  // [&quot;prop&quot;, &quot;method&quot;]  ));</code></pre><h3 id="4-for-of"><a href="#4-for-of" class="headerlink" title="4. for..of"></a>4. for..of</h3><hr><p>es6 新增方法，主要来遍历可迭代的对象（包括 Array, Map, Set, arguments 等），它主要用来获取对象 value 值，而 for..in 主要获取对象 key 值。<br>另外：可以由 break, continue, throw 或 return 终止。在这些情况下，迭代器关闭。</p><pre><code>let iterable = [10, 20, 30];for (let value of iterable) {value += 1;console.log(value);}// 11// 21// 31</code></pre><p>与 for..in 循环之间的区别：</p><pre><code>Object.prototype.objCustom = function() {};Array.prototype.arrCustom = function() {};let iterable = [3, 5, 7];iterable.foo = &apos;hello&apos;;for (let i in iterable) {  console.log(i); //  0, 1, 2, &quot;foo&quot;, &quot;arrCustom&quot;, &quot;objCustom&quot;}for (let i in iterable) {  if (iterable.hasOwnProperty(i)) {console.log(i); //  0, 1, 2, &quot;foo&quot;  }}for (let i of iterable) {  console.log(i); //  3, 5, 7}</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>其实这几个方法之间的差异主要在属性是否可可枚举，是来自原型，还是实例。<br>图片描述</p><p>开发中的实际应用<br>需求：将如下两个从后台不同端口获取的 json 对象数组整合处理成如下注释部分的 json 对象</p><pre><code>var goodsSpecJSON = [{&quot;SpecA&quot;: &quot;颜色&quot;}, {&quot;SpecB&quot;: &quot;容量&quot;}, {&quot;SpecC&quot;: &quot;大小&quot;}, {&quot;SpecD&quot;: &quot;尺寸&quot;}, {&quot;SpecE&quot;: &quot;套餐&quot;}];var goodsSpecList = [{c_id: 3133,costPrice: 0,discountPrice: 0,earn: 0,etime: null,flag: 0,goodsDetailCount: 199,goodsDetailId: &quot;100PgQ2xy08121409mY27&quot;,goodsDetailInventory: 199,goodsDetailOff: 0,goodsDetailPic: &quot;/upload/messageImage/1523281057461_Personal.jpg,/upload/messageImage/1523282906972_Personal.jpg,/upload/messageImage/1523283570897_Personal.jpg&quot;,goodsDetailPrice: 188,goodsDetailSpec: &quot;&quot;,goodsId: &quot;00Y1kR4r1029X822731o0&quot;,isHost: 0,managerEarn: 0,postage: 10,profit: 0,specA: &quot;红色&quot;,specB: &quot;32G&quot;,specC: &quot;小&quot;,specD: &quot;4.7寸&quot;,specE: &quot;套餐一&quot;,unionEarn: 0,vipPrice: 0}, {c_id: 3134,costPrice: 0,discountPrice: 0,earn: 0,etime: null,flag: 0,goodsDetailCount: 199,goodsDetailId: &quot;100PgQ2xy08121409mY27&quot;,goodsDetailInventory: 199,goodsDetailOff: 0,goodsDetailPic: &quot;/upload/messageImage/1523281057461_Personal.jpg,/upload/messageImage/1523282906972_Personal.jpg,/upload/messageImage/1523283570897_Personal.jpg&quot;,goodsDetailPrice: 188,goodsDetailSpec: &quot;&quot;,goodsId: &quot;00Y1kR4r1029X822731o0&quot;,isHost: 0,managerEarn: 0,postage: 10,profit: 0,specA: &quot;白色&quot;,specB: &quot;64G&quot;,specC: &quot;小&quot;,specD: &quot;5寸&quot;,specE: &quot;套餐二&quot;,unionEarn: 0,vipPrice: 0}, {c_id: 3135,costPrice: 0,discountPrice: 0,earn: 0,etime: null,flag: 0,goodsDetailCount: 199,goodsDetailId: &quot;100PgQ2xy08121409mY27&quot;,goodsDetailInventory: 199,goodsDetailOff: 0,goodsDetailPic: &quot;/upload/messageImage/1523281057461_Personal.jpg,/upload/messageImage/1523282906972_Personal.jpg,/upload/messageImage/1523283570897_Personal.jpg&quot;,goodsDetailPrice: 188,goodsDetailSpec: &quot;&quot;,goodsId: &quot;00Y1kR4r1029X822731o0&quot;,isHost: 0,managerEarn: 0,postage: 10,profit: 0,specA: &quot;黑色&quot;,specB: &quot;128G&quot;,specC: &quot;小&quot;,specD: &quot;4.7寸&quot;,specE: &quot;套餐一&quot;,unionEarn: 0,vipPrice: 0}, {c_id: 3136,costPrice: 0,discountPrice: 0,earn: 0,etime: null,flag: 0,goodsDetailCount: 199,goodsDetailId: &quot;100PgQ2xy08121409mY27&quot;,goodsDetailInventory: 199,goodsDetailOff: 0,goodsDetailPic: &quot;/upload/messageImage/1523281057461_Personal.jpg,/upload/messageImage/1523282906972_Personal.jpg,/upload/messageImage/1523283570897_Personal.jpg&quot;,goodsDetailPrice: 188,goodsDetailSpec: &quot;&quot;,goodsId: &quot;00Y1kR4r1029X822731o0&quot;,isHost: 0,managerEarn: 0,postage: 10,profit: 0,specA: &quot;蓝色&quot;,specB: &quot;64GG&quot;,specC: &quot;大&quot;,specD: &quot;4.5寸&quot;,specE: &quot;套餐二&quot;,unionEarn: 0,vipPrice: 0}];// var keys = {// &apos;颜色&apos;: [&apos;红色&apos;, &apos;白色&apos;],// &apos;容量&apos;: [&apos;8g&apos;, &apos;16g&apos;, &apos;32g&apos;, &apos;64g&apos;],// &apos;尺寸&apos;: [&apos;大&apos;, &apos;小&apos;, &apos;大&apos;],// &apos;套餐&apos;: [&apos;套餐一&apos;, &apos;套餐二&apos;, &apos;套餐三&apos;]// };// //SKU，Stock Keeping Uint(库存量单位)// var sku_list = [{// &apos;attrs&apos;: &apos;红色|16g|big|套餐二&apos;,// &apos;price&apos;: 120// }, {// &apos;attrs&apos;: &apos;红色|8g|big|套餐一&apos;,// &apos;price&apos;: 10// }, {// &apos;attrs&apos;: &apos;白色|16g|big|套餐二&apos;,// &apos;price&apos;: 28// }, {// &apos;attrs&apos;: &apos;红色|64g|small|套餐三&apos;,// &apos;price&apos;: 220// }, {// &apos;attrs&apos;: &apos;白色|32g|middle|套餐二&apos;,// &apos;price&apos;: 130// }, {// &apos;attrs&apos;: &apos;红色|32g|big|套餐一&apos;,// &apos;price&apos;: 120// }, ];</code></pre><p>实现：主要利用 Object.keys 方法获取对象的 key,value 值，配上 forEach 循环实现最终想要的结果。</p><pre><code>var keys = {};var sku_list = [];//原数据转换小写goodsSpecJSON = goodsSpecJSON.map(function (keyo) {var key = Object.keys(keyo)[0];var newkey = key.substring(0, 1).toLowerCase() + key.substring(1);var dic = {};dic[newkey] = keyo[key];return dic});//生成keysgoodsSpecJSON.forEach(function (keyo) {var key = Object.keys(keyo)[0]; //[&apos;specA&apos;]var val = keyo[key]; //颜色if (!keys.hasOwnProperty(val)) {keys[val] = [];}var hash = {};goodsSpecList.forEach(function (item, i) {if (hash[item[key]] === undefined) {hash[item[key]] = true;keys[val].push(item[key]);}// if (keys[val].indexOf(item[key]) === -1) {// keys[val].push(item[key]);// }});});console.log(keys)//生成sku_listgoodsSpecList.forEach(function (item) {var dic = {attrs: &apos;&apos;};goodsSpecJSON.forEach(function (keyo, j) {var key = Object.keys(keyo)[0];dic.attrs += item[key] + (j === goodsSpecJSON.length - 1 ? &apos;&apos; : &apos;|&apos;);dic.price = item.goodsDetailPrice;dic.goodsDetailCount = item.goodsDetailCount;dic.goodsDetailId = item.goodsDetailId;});sku_list.push(dic);});console.log(sku_list)</code></pre><p>输出结果：</p><p><img src="https://i.imgur.com/gOOuYv0.png" alt="示例结果"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;js 中几种遍历对象的方法，包括 for..of、for..in、Object.keys、Object.getOwnProperty,它们在使用场景方面各有不同。&lt;/p&gt;
&lt;p&gt;js 对象的属性中可直接用、可访问到的属性分为数据属性和访问器属性。&lt;/p&gt;
&lt;h4 id=&quot;数
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
      <category term="Object.keys" scheme="http://yoursite.com/categories/js/Object-keys/"/>
    
    
      <category term="Object.keys" scheme="http://yoursite.com/tags/Object-keys/"/>
    
      <category term="遍历" scheme="http://yoursite.com/tags/%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>简洁的 Markdown 编辑器 Smark</title>
    <link href="http://yoursite.com/2018/08/19/Markdown%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>http://yoursite.com/2018/08/19/Markdown编辑器/</id>
    <published>2018-08-19T13:05:15.000Z</published>
    <updated>2018-08-19T09:48:51.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简洁的-Markdown-编辑器-Smark"><a href="#简洁的-Markdown-编辑器-Smark" class="headerlink" title="简洁的 Markdown 编辑器 Smark"></a>简洁的 Markdown 编辑器 Smark</h1><p><img align="left" src="https://raw.githubusercontent.com/elerao/Smark/master/README/logo.png" width="100"></p><p>说白了只是为了自己方便使用，并没什么新奇的东西。我使用 <a href="http://johnmacfarlane.net/pandoc/" target="_blank" rel="noopener">pandoc</a> 来转化 <code>markdown</code>，但是我不想在修改文件时总是在编辑器、文字终端和浏览器间换来换去，因此我写了一个简单的编辑器，它在后台调用 <code>pandoc</code> 将当前编辑的 <code>markdown</code> 内容转化为 <code>HTML</code>，而后将 <code>HTML</code> 在 <code>smark</code> 中的浏览器中显示出来，就是这么回事。Smark 依赖于 <a href="http://johnmacfarlane.net/pandoc/" target="_blank" rel="noopener"><code>pandoc</code></a>、<a href="http://qt-project.org/" target="_blank" rel="noopener"><code>Qt 4.8</code></a> 和 <a href="http://www.mathjax.org" target="_blank" rel="noopener"><code>MathJax</code></a>，在此向上述软件包开发者们致敬。请注意继承于 pandoc 的发布协议，Smark 同样遵循 <a href="http://www.gnu.org/copyleft/gpl.html" target="_blank" rel="noopener">GPL</a>，如有任何疑问请联系 <a href="elerao.ao@gmail.com">elerao.ao@gmail.com</a>，我将尽快做出回复。</p><p>主要特性：</p><ul><li><code>Windows</code> / <code>Linux</code> 等主流系统跨平台支持；</li><li>完美支持 <code>LaTex</code> 数学公式、脚注、尾注等，支持使用本地 <code>MathJax</code> 调用，不需要在线访问 <code>MathJax CDN</code>；</li><li>用户可配置的 <code>Markdown</code> 语法高亮显示，美观整洁；</li><li>多种格式文件导出支持，可将当前 <code>Markdown</code> 文件另存为 <code>HTML</code>、 <code>Miscrosoft Word</code>、<code>OpenOffice / LibreOffice ODT Document</code>、<code>Latex</code>、<code>PDF</code>、<code>reStructured Text</code>、<code>Media Wiki markup</code>、<code>epub</code> 以及 <code>plain txt</code> 等格式文件输出；</li><li>可通过用户指明 <code>CSS</code> 文件定义显示式样；</li><li>简洁友好的界面布局，尽可能地凸显正在编辑的内容；</li><li>系统、完备的各类快捷键，极大地提高了工作效率；</li></ul><h2 id="安装-Smark"><a href="#安装-Smark" class="headerlink" title="安装 Smark"></a>安装 Smark</h2><p>对于 <code>Win32</code> 平台的用户，您可以直接下载当前版本的可执行程序 <a href="http://pan.baidu.com/s/1ntMCVFV" target="_blank" rel="noopener">Smark-X.X-Win32-portable.zip</a>。对于其它平台的用户，可以下载当前版本的 Smark 源代码 <a href="http://pan.baidu.com/s/1ntMCVFV" target="_blank" rel="noopener">Smark-X.X-src.zip</a>在本平台上进行编译即可，一般地您可以按照如下步骤编译 <code>Smark</code>：</p><ol><li><p>安装依赖的程序包:</p><pre><code>$ sudo apt-get install qtsdk$ sudo apt-get install pandoc</code></pre><p>如果您不使用 <code>apt-get</code> 作为软件包管理器，自己谷歌搜索如何安装这两个程序包</p></li><li><p>下载 Smark 源代码 <a href="http://pan.baidu.com/s/1ntMCVFV" target="_blank" rel="noopener">Smark-X.X-src.zip</a>，解压并编译:</p><pre><code>$ qmake -project$ qmake$ make</code></pre></li><li><p>把编译出的可执行文件移动到您的 <code>[bin]</code> 路径下即可使用，此时 <code>Smark</code> 将使用默认的 <code>CSS</code> 样式表和基于 <code>MathJax CDN</code> 的 <code>MathJax</code> 访问。如果想要得到与 <code>Windows</code> 平台下完全一致的体验，您还需下载 <a href="http://pan.baidu.com/s/1ntMCVFV" target="_blank" rel="noopener">smark-2.0-resource.zip</a> 解压倒 <code>Smark</code> 的安装目录下并进行设置。</p></li></ol><h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p align="center"><br><br><img src="https://raw.githubusercontent.com/elerao/Smark/master/README/screenshot.png" width="95%"><br><br>Windows 7 下的 Smark 运行截图<br><br><br><br><img src="https://raw.githubusercontent.com/elerao/Smark/master/README/option-dialog.png" width="95%"><br><br>Windows 7 下的 Smark 配置选项对话框<br></p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="64-位-Windows-下提示无法运行-pandoc："><a href="#64-位-Windows-下提示无法运行-pandoc：" class="headerlink" title="64 位 Windows 下提示无法运行 pandoc："></a>64 位 Windows 下提示无法运行 pandoc：</h3><p>这是因为 <a href="http://pan.baidu.com/s/1ntMCVFV" target="_blank" rel="noopener">Smark-X.X-Win32-portable.zip</a> 中自带的 pandoc.exe 是 32 位系统下的，您可以通过下载安装包 <a href="http://pan.baidu.com/s/1ntMCVFV#path=%252Fsmark" target="_blank" rel="noopener">pandoc-1.13.1-win64.msi</a> 直接安装 64 位的 <code>pandoc</code> 而删除 <a href="http://pan.baidu.com/s/1ntMCVFV" target="_blank" rel="noopener">Smark-X.X-Win32-portable.zip</a> 中自带的 32 位的 <code>pandoc.exe</code>。</p><h3 id="谷歌输入法无法输入问题"><a href="#谷歌输入法无法输入问题" class="headerlink" title="谷歌输入法无法输入问题"></a>谷歌输入法无法输入问题</h3><p>貌似大凡使用 <code>QTextEdit</code> 部件的地方都存在这样的问题，这是因为您未开启 谷歌输入法的内嵌编辑模式，可通过点击 “谷歌输入法设置对话框” 中 “设置内嵌编辑模式” 按钮，后勾选 “使用内嵌编辑模式” 即可，如下图所示：</p><p align="center"><br><br><img src="https://raw.githubusercontent.com/elerao/Smark/master/README/google-input-setting.png" width="60%"><br></p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h3 id="现有问题："><a href="#现有问题：" class="headerlink" title="现有问题："></a>现有问题：</h3><ul><li>在 Qt5 下编译的 WebView 无法完整地加载 CSS 中的设置，Qt4 下没问题；</li><li>改动后的 Markdwon 语法高亮的超链接 和 加粗 的正则表达式匹配有问题；</li><li>导出 PDF 和打印时的内容分页问题；</li></ul><h3 id="待添加功能"><a href="#待添加功能" class="headerlink" title="待添加功能"></a>待添加功能</h3><ul><li>仿照 QtCreator 3.1.xx 中编辑器的多行同时编辑实现，支持 Sublime 等软件所支持的多行同时编辑；</li><li>与 百度云、Google Drive、OneDrive 内容同步，这个以后再说；</li></ul><h2 id="附录：Smark-的快捷键列表"><a href="#附录：Smark-的快捷键列表" class="headerlink" title="附录：Smark 的快捷键列表"></a>附录：Smark 的快捷键列表</h2><p id="hotkey"></p><p>全局</p><pre><code>Esc              : 逐步隐藏所有不必要的部件，退出全屏显示Tab              : 增加所选诸行的缩进（四个空格）Ctrl + Tab       : 减小所选诸行的缩进（四个空格）</code></pre><p>文件菜单</p><pre><code>Ctrl + N         : 新建 markdown 文件Ctrl + O         : 打开 markdown 文件Ctrl + S         : 保存当前 markdown 文件Ctrl + Shift + S : 将当前文件另存为支持的格式Ctrl + W         : 关闭当前 markdown 文件Ctrl + P         : 打印当前 markdown 文件Ctrl + Q         : 退出 Smark</code></pre><p>视图菜单</p><pre><code>F6               : 预览模式视图F7               : 阅读模式视图F8               : 编辑模式视图F11              : 进入 / 退出全屏显示</code></pre><p>编辑菜单</p><pre><code>F5               : 刷新 HTML 显示Ctrl + Shift + C : 查看 HTML 源代码Ctrl + C         : 复制Ctrl + X         : 剪切Ctrl + P         : 粘贴Ctrl + Z         : 撤消Ctrl + Y         : 重做Ctrl + F         : 查找</code></pre><p>插入菜单</p><pre><code>Ctrl + Shift + P : 插入图片Ctrl + Shift + L : 插入链接Ctrl + Shift + M : 插入数学公式</code></pre><p>格式菜单</p><pre><code>Ctrl + B         : 加粗Ctrl + I         : 倾斜Ctrl + U         : 下划线Ctrl + ]         : 加大字号Ctrl + [         : 减小字号Ctrl + Down      : 下标Ctrl + Up        : 上标Ctrl + `         : 代码Ctrl + &apos;         : 引用Ctrl + L         : 内容左对齐Ctrl + R         : 内容右对齐Ctrl + E         : 内容居中</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简洁的-Markdown-编辑器-Smark&quot;&gt;&lt;a href=&quot;#简洁的-Markdown-编辑器-Smark&quot; class=&quot;headerlink&quot; title=&quot;简洁的 Markdown 编辑器 Smark&quot;&gt;&lt;/a&gt;简洁的 Markdown 编辑器 Sma
      
    
    </summary>
    
      <category term="工具类" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
      <category term="Smark" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/Smark/"/>
    
    
      <category term="编辑器" scheme="http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
      <category term="Smark" scheme="http://yoursite.com/tags/Smark/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/08/19/hello-world/"/>
    <id>http://yoursite.com/2018/08/19/hello-world/</id>
    <published>2018-08-19T11:35:15.000Z</published>
    <updated>2018-08-19T09:48:19.925Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="工具类" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
      <category term="hexo" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/08/19/404/"/>
    <id>http://yoursite.com/2018/08/19/404/</id>
    <published>2018-08-19T09:42:18.623Z</published>
    <updated>2018-08-19T09:47:59.820Z</updated>
    
    <content type="html"><![CDATA[<!DOCTYPE HTML><html><head>    <meta http-equiv="content-type" content="text/html;charset=utf-8;">    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    <meta name="robots" content="all">    <meta name="robots" content="index,follow">    <link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"></head><body>    <script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homepageurl="/" homepagename="回到我的主页">  </script>    <script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"></script>    <script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"></script></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!DOCTYPE HTML&gt;
&lt;html&gt;

&lt;head&gt;
    &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible
      
    
    </summary>
    
    
  </entry>
  
</feed>
